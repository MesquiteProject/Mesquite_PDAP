/* PDAP:PDTREE package for Mesquite  copyright 2001-2009 P. Midford & W. MaddisonPDAP:PDTREE is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.The web site for PDAP:PDTREE is http://mesquiteproject.org/pdap_mesquite/This source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)*/package mesquite.pdap.lib;import mesquite.lib.*;import mesquite.lib.tree.Tree;import mesquite.cont.lib.*;/** *  * @author Peter E. Midford * created Aug 2001 * */public class BivariateContrastCalculator extends ContrastCalculator{	private ContinuousDistribution states2;	private double [] contrasts2 = null;	private double [] rawContrasts2 = null;	private double [] x2 = null;	private double [] vPrime2 = null;   // mostly used for flagging branches with missing data	/** Constructor for a bivariate calculator */	public BivariateContrastCalculator(Tree theTree, ContinuousDistribution observedStates1, ContinuousDistribution observedStates2){		if (theTree == null || observedStates1 == null || observedStates2 == null) {			MesquiteMessage.printStackTrace("A null value was passed to the constructor for BivariateContrastCalculator");			tree = null;			states = null;			states2 = null;		}		else {			tree = theTree;			states = observedStates1;			states2 = observedStates2;			numNodes = theTree.getNumNodeSpaces();			checkArrays();		}	}		/** This tries to reuse as much memory as possible, while resetting everything */	private void checkArrays() {		if (contrasts == null || contrasts.length != numNodes || 		     contrasts2 == null || contrasts2.length != numNodes) {			contrasts = new double[numNodes];			rawContrasts = new double[numNodes];			vPrime = new double[numNodes];			x = new double[numNodes];			stdDev = new double[numNodes];			height = new double[numNodes];            rawHeight = new double[numNodes];			weightPassThrough = new double[numNodes];			contrasts2 = new double[numNodes];			rawContrasts2 = new double[numNodes];			x2 = new double[numNodes];			vPrime2 = new double[numNodes];		}		else {			DoubleArray.deassignArray(contrasts);			DoubleArray.deassignArray(rawContrasts);  //should this be zeroArray?			DoubleArray.deassignArray(x);			DoubleArray.deassignArray(vPrime);			DoubleArray.deassignArray(stdDev);            DoubleArray.deassignArray(height);            DoubleArray.deassignArray(rawHeight);			DoubleArray.deassignArray(weightPassThrough);			DoubleArray.deassignArray(contrasts2);			DoubleArray.deassignArray(rawContrasts2);			DoubleArray.deassignArray(x2);			DoubleArray.deassignArray(vPrime2);		}	}        public void reinitialize(Tree theTree,boolean[] theDeletions, ContinuousDistribution observedStates1,ContinuousDistribution observedStates2){        if (theTree == null || observedStates1 == null || observedStates2 == null) {            MesquiteMessage.printStackTrace("A null value was passed to the constructor for BivariateContrastCalculator");        }        else {            tree = theTree;            states = observedStates1;            states2 = observedStates2;            numNodes = theTree.getNumNodeSpaces();            checkArrays();        }    }        /**     * setter (with null checking) for setting the calculator's x trait     * @param observedStates2 holds the first (x) trait set     */    public void setObserved1(ContinuousDistribution observedStates1){        if (observedStates1 == null) {            MesquiteMessage.printStackTrace("A null value was passed to setObserved1 in BivariateContrastCalculator");            return;        }        states = observedStates1;    }                /**     * setter (with null checking) for setting the calculator's y trait     * @param observedStates2 holds the second (y) trait set     */    public void setObserved2(ContinuousDistribution observedStates2){        if (observedStates2 == null) {            MesquiteMessage.printStackTrace("A null value was passed to setObserved2 in BivariateContrastCalculator");            return;        }        states2 = observedStates2;    }            	/*.................................................................................................................*/    /**     * This calculates adjusted branch lengths and standard deviations of contrasts.  This is recursive, call with node == root.     * @param node specifies node to calculate from.     */	protected void vCalculation(int node) {		for (int daughter = tree.firstDaughterOfNode(node); tree.nodeExists(daughter); daughter = tree.nextSisterOfNode(daughter))			vCalculation(daughter);		if (tree.nodeIsInternal(node)) {			int left = tree.firstDaughterOfNode(node);			int right = tree.lastDaughterOfNode(node);			if (MesquiteDouble.isCombinable(vPrime[left]) && MesquiteDouble.isCombinable(vPrime[right]) &&  			    MesquiteDouble.isCombinable(vPrime2[left]) && MesquiteDouble.isCombinable(vPrime2[right])){ // good in both characters and both branches				vPrime[node] = branchWeight(node) + (vPrime[left] * vPrime[right]) / (vPrime[left] + vPrime[right]); /*vPrime used temporarily!*/				vPrime2[node] = branchWeight(node) + (vPrime2[left] * vPrime2[right]) / (vPrime2[left] + vPrime[right]); /* same for vPrime2 */				stdDev[node] = Math.sqrt(vPrime[right] + vPrime[left]);				}			else if (MesquiteDouble.isCombinable(vPrime[left]) && MesquiteDouble.isCombinable(vPrime2[left])) { // only left good					weightPassThrough[node] = branchWeight(left);					//vPrime[left] += branchWeight(node);					vPrime[node] = branchWeight(node)+vPrime[left];					vPrime2[node] = branchWeight(node)+vPrime2[left];					stdDev[node] = MesquiteDouble.unassigned;			}			else if (MesquiteDouble.isCombinable(vPrime[right]) && MesquiteDouble.isCombinable(vPrime2[right])){ // only right good					weightPassThrough[node] = branchWeight(right);					//vPrime[right] += branchWeight(node);					vPrime[node] = branchWeight(node) + vPrime[right];					vPrime2[node] = branchWeight(node) + vPrime2[right];					stdDev[node] = MesquiteDouble.unassigned;			}			else { // both bad  - so the whole subtree below this node is dead?					vPrime[node] = MesquiteDouble.unassigned;					vPrime2[node] = MesquiteDouble.unassigned;					stdDev[node] = MesquiteDouble.unassigned;			}		}				else { // Check that the node actually has data available			if (states != null  && 			     MesquiteDouble.isCombinable(x[node]=states.getState(tree.taxonNumberOfNode(node), 0)) &&			     MesquiteDouble.isCombinable(x2[node]=states2.getState(tree.taxonNumberOfNode(node), 0))) {  			     //x[node] = states.getState(tree.taxonNumberOfNode(node), 0);			     vPrime[node] = vPrime2[node] = branchWeight(node);			}			else{  //bad data				x[node] = x2[node] = MesquiteDouble.unassigned;				vPrime[node] = vPrime2[node] = MesquiteDouble.unassigned;			}		}	}		/*.................................................................................................................*/	/**	 * This calculates node value reconstructions and contrasts (raw and standardized).  This is recursive, call with node == root.	 * @param node specifies node to calculate from.	 */	protected void xCalculation(int node) {		for (int daughter = tree.firstDaughterOfNode(node); tree.nodeExists(daughter); daughter = tree.nextSisterOfNode(daughter))			xCalculation(daughter);		if (tree.nodeIsInternal(node)) {			int left = tree.firstDaughterOfNode(node);			int right = tree.lastDaughterOfNode(node);			//Debugg.println("inside x calculation; x[" + left + "] = " + x[left] + "; x[" + right + "] = " + x[right]);			if (MesquiteDouble.isCombinable(x[left]) && MesquiteDouble.isCombinable(x[right]) &&			     MesquiteDouble.isCombinable(x2[left]) && MesquiteDouble.isCombinable(x2[right])) {  // good contrast				x[node] = (vPrime[right]*x[left] + vPrime[left]*x[right] )/(vPrime[left] +vPrime[right]);  				x2[node] = (vPrime[right]*x2[left] + vPrime[left]*x2[right] )/(vPrime[left] +vPrime[right]);  				//Debugg.println("inside x calculation; x[" + left + "] = " + x[left] + "; x[" + right + "] = " + x[right]);				rawContrasts[node] =(x[left] - x[right]);				rawContrasts2[node] =(x2[left] - x2[right]);				contrasts[node] = rawContrasts[node]/stdDev[node];				contrasts2[node] = rawContrasts2[node]/stdDev[node];			}			else {				rawContrasts[node] = rawContrasts2[node] = MesquiteDouble.unassigned;				contrasts[node] = contrasts2[node] = MesquiteDouble.unassigned;				x[node] = x2[node] = MesquiteDouble.unassigned;  // Default unless both values of left or both values of right are good				if(MesquiteDouble.isCombinable(x[right]) && MesquiteDouble.isCombinable(x2[right]))  {					x[node] = x[right];  // good values for both from right, but no value from left to average with, so all we can do is propagate down!					x2[node] = x2[right];				}				if(MesquiteDouble.isCombinable(x[left]) && MesquiteDouble.isCombinable(x2[left])) {					x[node] = x[left];  // good values for both from left, but no value from right to average with, so all we can do is propagate down!					x2[node] = x2[left];				}			}		}		else {			//Debugg.println("inside x calculation extracting tip value; states[" + node + "] = " + states.getState(tree.taxonNumberOfNode(node), 0));			if (states != null  && MesquiteDouble.isCombinable(states.getState(tree.taxonNumberOfNode(node), 0))) {				x[node] = states.getState(tree.taxonNumberOfNode(node), 0); 			}			else				x[node] = MesquiteDouble.unassigned;			//Debugg.println("inside x calculation extracting tip value; states2[" + node + "] = " + states2.getState(tree.taxonNumberOfNode(node), 0));			if (states2 != null  && MesquiteDouble.isCombinable(states2.getState(tree.taxonNumberOfNode(node), 0))) { 				x2[node] = states2.getState(tree.taxonNumberOfNode(node), 0); 			}			else				x2[node] = MesquiteDouble.unassigned;			stdDev[node] = MesquiteDouble.unassigned;			contrasts[node] = MesquiteDouble.unassigned;			contrasts2[node] = MesquiteDouble.unassigned;		}	}	/** 	 * This (overloaded) copies tip values into the x and x2 arrays.  This is recursive, call with node == root.	 *  @param node specifies node to fill from	 *  @return double [] - the array of tip values, internal node values are set to MesquiteDouble.unassigned 	 */	public double [] fillTips(int node) {		for (int daughter = tree.firstDaughterOfNode(node); tree.nodeExists(daughter); daughter = tree.nextSisterOfNode(daughter))			fillTips(daughter);		if (tree.nodeIsInternal(node)) {			x[node] = x2[node] = MesquiteDouble.unassigned;		}		else {			x[node] = states.getState(tree.taxonNumberOfNode(node), 0);  			x2[node] = states2.getState(tree.taxonNumberOfNode(node), 0);  		}		return x;	}		/** Just returns the contrast2 array, without recalculating */	public double [] getContrasts2() {		return contrasts2;	}			/** Just returns the node values (tip and interior), without recalculating */	public double [] getNodeValues2() {		return x2;	}        /** Just returns rawContrasts2 array, without recalculating */    public double[] getRawContrasts2() {        return rawContrasts2;    }}