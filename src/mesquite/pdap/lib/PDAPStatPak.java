/* PDAP:PDTREE package for Mesquite  copyright 2001-2009 P. Midford & W. MaddisonPDAP:PDTREE is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.The web site for PDAP:PDTREE is http://mesquiteproject.org/pdap_mesquite/This source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.pdap.lib;/*~~  */import mesquite.lib.*;import JSci.maths.statistics.TDistribution;    // for p-value calculations/** PDAPStatPaks are based on a record structure used in the original Pascal * code for DOS PDAP. I have based three subclasses off of this: one for  * regular regression (used in old screens 1-8,10,11) one for regression  * through the origin (screen 9) and one for the regression based on root * reconstruction (DOS screens 9A,B,C).  The last one is clearly the odd one * of the three descendant classes. * @author Peter E. Midford */public abstract class PDAPStatPak{    private static final int INITINTEGER = MesquiteInteger.unassigned;    private static final double INITDOUBLE = MesquiteDouble.unassigned;    protected int n1 = 0;            // axis selection - this may be an obsolete holdover from pascal code PEM    protected int n2 = 0;            // axis selection    protected double min[];    protected double max[];    protected int number = INITINTEGER;        // tips or contrasts    protected int df = INITINTEGER;                // nominal degrees of freedom    protected double mean[];      // means     protected double variance[];    protected double cov = INITDOUBLE;    protected double corr = INITDOUBLE;    protected double rma = INITDOUBLE;        //reduced major axis    protected double rmay = INITDOUBLE;       //reduced major axis y intercept    protected double ma = INITDOUBLE;         //major axis    protected double may = INITDOUBLE;        //major axis y intercept    protected double ls = INITDOUBLE;         //least squares slope    protected double lsy = INITDOUBLE;        //least square y intercept    protected TDistribution tStats = null; //an object for calculating t statistics from jsci    public boolean lsregok;           //true if ok to do regression    protected boolean  contempTips = false;    protected MesquiteNumber[] writableResults = null;    /**     * Constructor - just sets some fields containing arrays     */    public PDAPStatPak() {        min = new double[]  {MesquiteDouble.infinite , MesquiteDouble.infinite};        max = new double[] { MesquiteDouble.negInfinite, MesquiteDouble.negInfinite};        mean = new double[] {INITDOUBLE,INITDOUBLE};        variance = new double[] {INITDOUBLE,INITDOUBLE};    }    /** A common method for reseting the chart bounds, which may get      * subsequently set in doCalculations      * @param chart the chart to check and operate on     */    protected void resetChartBounds(MesquiteChart chart) {        //If it's time to recalculate, then turn off stale chart contraints        if (chart!=null && (chart.isMinimumYConstrained() || chart.isMaximumYConstrained())){            chart.deConstrainMinimumX();            chart.deConstrainMaximumX();            chart.deConstrainMinimumY();            chart.deConstrainMaximumY();        }    }    /**    Do basic calculations on number arrays passed.  After these are done, it should be possible to query    the statpak for results.  Should return whether or not chart needs to be re-munched    */    public abstract boolean doCalculations(NumberArray xArray, NumberArray yArray, MesquiteChart chart);    // A few simple methods that everyone shares and that provide some encapsulation    /** returns the number of data points (for df or variance calculations) 	 @return integer */    public int getNumber() {        return number;    }    /** 	@return integer one less than the number of data points (for df calculations)  	*/    public int getNumberMinus1() {        return number-1;    }    /**      * This returns what the statpak thinks the degrees of freedom should be      * @see getNumber	 * @return degrees of freedom 	*/    public int getDegreesOfFreedom() {        return df;    }    /** 	 @return the correlation coefficient	 */    public double getCorrelationCoefficient(){        return corr;    }    /** 	 * @return the calculated covariance 	 */    public double getCovariance() {        return cov;    }    /**      * @return the calculated reduced major axis slope      */    public double getReducedMajorAxis() {        return rma;      }    /**      * @return the calculated reduced major axis y intercept      */    public double getReducedMajorAxisYIntercept() {        return rmay;      }    /**      * @return the calculated major axis slope      */    public double getMajorAxis() {        return ma;      }    /**      * @return the calculated major axis y intercept      */    public double getMajorAxisYIntercept() {        return may;      }    /**      * @return the standard least squares regression slope      */    public double getLeastSquaresSlope() {        return ls;    }    /**      * @return the standard least squares y intercept      */    public double getLeastSquaresYIntercept() {        return lsy;    }    /**      * @return true if regression results are valid (>=2 points, slope not infinite, etc.)      */    public boolean getRegressionOK() {        return lsregok;    }    /**      * @return calculated p-value      */    public abstract double getPValue();    /**      * @return calculated variance      */    public double getVariance(int which){        if (which >= 0 && which < 2)            return variance[which];        return MesquiteDouble.unassigned;    }    /**     * @return calculated mean      */    public double getMean(int which){        if (which >= 0 && which < 2)            return mean[which];        return MesquiteDouble.unassigned;    }    // Both the regular regression StatPak takes values directly    // from the array, rather than off the tree (like the PDAP2CTStatPak).  So following are     // methods that these two share.  The PDAP2CTStatPak overrides this.    /**     * sets the min and max fields to the appropriate minima and maxima for      * the two NumberArrays since min and max are zero based, maybe the names     * data0 and data1 will be less confusing     * @param data0 data for the first (horizontal) character trait     * @param data1 data for the second (vertical) character trait     */    protected void calcBounds(NumberArray data0, NumberArray data1) {        min[0] = MesquiteDouble.infinite;        min[1] = MesquiteDouble.infinite;        max[0] = MesquiteDouble.negInfinite;        max[1] = MesquiteDouble.negInfinite;        number = 0;        for (int i = 0; i < data0.getSize(); i++)            if (data0.isCombinable(i) && data1.isCombinable(i)) {                number++;                if (data0.getDouble(i) > max[0])                    max[0] = data0.getDouble(i);                if (data1.getDouble(i) > max[1])                    max[1] = data1.getDouble(i);                if (data0.getDouble(i) < min[0])                    min[0] = data0.getDouble(i);                if (data1.getDouble(i) < min[1])                    min[1] = data1.getDouble(i);            }    }    // Accessers for the values set in getBounds     /**      * returns the minimum value of the character/trait specfied by index in the data set	   @param which specifies which character/trait	   @return double - the minimum value 	 */    public double getMin(int which) {        if (which >= 0 && which < 2)            return min[which];        return MesquiteDouble.unassigned;    }    /**      * returns the maximum value of the character/trait specified by index in the data set        @param which specifies which character/trait       @return double - the minimum value      */   public double getMax(int which) {        if (which >= 0 && which < 2)            return max[which];        return MesquiteDouble.unassigned;    }    /**     *  calculates raw sums, sums of squares and cross-product terms.     * @param data0 data for the first (horizontal) character trait     * @param data1 data for the second (vertical) character trait     * @param sx sum of x (first trait) values     * @param sx2 sum of squares of x (first trait) values     * @param sy sum of y (second trait) values     * @param sxy sum of cross-products of trait values     */    protected void getSums(NumberArray data0,             NumberArray data1,	            MesquiteDouble sx,             MesquiteDouble sx2,	            MesquiteDouble sy,            MesquiteDouble sxy) {        for (int i = 0; i < data0.getSize(); i++)            if (data0.isCombinable(i) && data1.isCombinable(i)) {                sx.add(data0.getDouble(i));                sx2.add(data0.getDouble(i)*data0.getDouble(i));                sy.add(data1.getDouble(i));                sxy.add(data0.getDouble(i)*data1.getDouble(i));             }    }    /**     * And one for setting count based on the number of internal nodes in a tree     * @param tree to traverse     * @param node should be tree.root     */    public void countInternalNodes(Tree tree, int node) {        number = tree.numberOfInternalsInClade(node);    }    /**     *  Returns text results as String      *  @return summary for text pane of chart     */    public abstract String flst();    /**     * Returns results as brief String for use in legends      * @return summary for legend     */    public abstract String getLegendText();    /** Returns results as array with MesquiteNumbers */    public abstract MesquiteNumber[] getWritableResults();    /*-----------------------------------------*/    /** This function calculates the mean height of all the tree's tips.          This provides a default value for Vh.   Vh is the assumed height         of a tip when calculating a prediction interval.  The program reports        whether tips are contemporaneous, using a tolerance of 1E-10, the         same tolerance used for deciding whether a tip has a depth of zero.         @param tree for which height is calculated        @return height of the tree        */                       public double getMeanHeight(Tree tree){        final int tipList [] = tree.getTerminalTaxa(tree.getRoot());        double oldHeight = quickHeight(tree,tree.nodeOfTaxonNumber(tipList[0]));        double sum = oldHeight;        double currentHeight;        boolean assignedBranches = true;        for (int i=1;i< tipList.length;i++)  // already did tip 0.            tipList[i] = tree.nodeOfTaxonNumber(tipList[i]);        contempTips = true;        for(int i = 1;(i<tipList.length) && assignedBranches;i++) {            currentHeight = quickHeight(tree, tipList[i]);            if (MesquiteDouble.isCombinable(currentHeight)) {                sum += currentHeight;                if (Math.abs((oldHeight-currentHeight)/currentHeight) > 1E-10)                     contempTips = false;                oldHeight = currentHeight;            }            else assignedBranches = false;        }        if (assignedBranches)             return sum/tipList.length;        else             return MesquiteDouble.unassigned;    }    /*-----------------------------------------*/    /**  A simple method to calculate the height of a tip, used to calculate the mean tip height as a proposed default for Vh */    private double quickHeight(Tree tree, int node) {        final int root = tree.getRoot();        int tmp = node;        double height = 0.0;        do {            height += tree.getBranchLength(tmp);            tmp = tree.motherOfNode(tmp);        }        while(tmp != root);        return height;    }    /**     * the getMeanHeight method sets a flag if all the tips are contemporaneous     * and therefore have a height equal to the returned mean.  This method      * returns the setting of the flag for contemporaneous tips.     * @return value of contemporary tips flag     */    public boolean getContempTips(){        return contempTips;    }}