/* PDAP:PDTREE package for Mesquite  copyright 2001-2009 P. Midford & W. MaddisonPDAP:PDTREE is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.The web site for PDAP:PDTREE is http://mesquiteproject.org/pdap_mesquite/This source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)*/package mesquite.pdap.lib;import mesquite.lib.*;public class NoPolyTree extends MesquiteTree {    MesquiteTree original;    public NoPolyTree (MesquiteTree tree) {        super(tree.getTaxa());        original = tree;        setToClone(tree);    }    public void disconnect(){        original = null;    }    public void notifyListeners(Object caller, Notification notification) {         int code = Notification.getCode(notification);        if (code == MesquiteListener.SELECTION_CHANGED) {            original.notifyListeners(caller, notification);        }        super.notifyListeners(caller, notification);    }    /*-----------------------------------------*/    /** Sets whether or not the part is selected */    public void setSelected(int part, boolean select) {        original.setSelected(part, select);        super.setSelected(part,select);    }    /*-----------------------------------------*/    /** Deselects all parts */    public void deselectAll(){        original.deselectAll();        super.deselectAll();    }    /*-----------------------------------------*/    /** Selects all parts */    public void selectAll(){        original.selectAll();        super.selectAll();    }        /*-----------------------------------------*/    public void setToClone(MesquiteTree tree){        super.setToClone(tree);        polysToZeroLength();    }    /*-----------------------------------------*/    /** Sets the tree to be a default bush.*/    public void setToDefaultBush(int numTaxa, boolean notify) {        super.setToDefaultBush(numTaxa, notify);        polysToZeroLength();    }    /*-----------------------------------------*/    /** Collapses branch to yield polytomy.*/    public synchronized boolean collapseBranch(int node, boolean notify) {           boolean c = super.collapseBranch(node, notify);        polysToZeroLength();        return c;    }        /*-----------------------------------------*/    /** Collapses all internal branches within clade above node, to yield bush.*/    public synchronized boolean collapseAllBranches(int node, boolean below, boolean notify) {           boolean c = super.collapseAllBranches(node, below, notify);        polysToZeroLength();        return c;    }        /*-----------------------------------------*/    /** Checks for polytomies in the tree     * @param node      */    public int findPolytomy(int node) {        if (nodeIsTerminal(node))            return -1;        if (nodeIsPolytomous(node))            return node;        for (int d = firstDaughterOfNode(node); nodeExists(d); d = nextSisterOfNode(d))            if (hasPolytomies(d))                return findPolytomy(d);        return -1;    }        /*-----------------------------------------*/    /** test for presence of polytomies     * @return true if tree has polytomies     */    public boolean hasZLBs(){        return (countZLBsHelper(getRoot(),false)>0);    }        public boolean hasZLBs(boolean ignoreRootTritomies){        return (countZLBsHelper(getRoot(),ignoreRootTritomies) >0);    }        public int countZLBs(boolean ignoreRootTritomies){        return countZLBsHelper(getRoot(),ignoreRootTritomies);    }        /* This is a helper function */    private int countZLBsHelper(int node, boolean ignoreRootTritomies) {        if(nodeIsInternal(node)) {            int count = 0;            if ((getBranchLength(node) == 0.0) && // PDAP roots are ZLB's (arbitrarily)                    ((node != getRoot() &&                            (!ignoreRootTritomies || motherOfNode(node) != getRoot())))) {                 count++;            }            for(int daughter = firstDaughterOfNode(node); nodeExists(daughter);daughter=nextSisterOfNode(daughter))                count += countZLBsHelper(daughter,ignoreRootTritomies);            return count;        }        else return 0;    }    /*-----------------------------------------*/    private void polysToZeroLength(){        if (!checkAncestorFunctionEquivalence(original.getRoot()))            MesquiteMessage.warnProgrammer("error 1: PDAP NoPolyTree doesn't match original");        while (hasPolytomies(getRoot())){            final int p = findPolytomy(getRoot());            final int d = firstDaughterOfNode(p);            final double origDL = getBranchLength(d);            final int ns = nextSisterOfNode(d);            final double origNSL = getBranchLength(ns);            moveBranch(d, ns, false);            setBranchLength(d, origDL, false);            setBranchLength(ns, origNSL, false);            setBranchLength(firstDaughterOfNode(p), 0, false);        }        if (!checkAncestorFunctionEquivalence(original.getRoot()))            MesquiteTrunk.mesquiteTrunk.alert("error 2: PDAP NoPolyTree doesn't match original.  Original  " + original.writeTreeWithNodeNumbers() + " noPolyTree " + this.writeTreeWithNodeNumbers());    }    /*-----------------------------------------*/    /** Checks whether this & original tree have save ancestor functions.  To ensure tree node numbering remains equivalent for selection synchronization.     * @param oNode specifies node to check      * @return true when current tree and original tree have equivalent numbering     */    private boolean checkAncestorFunctionEquivalence(int oNode) {        if (original.nodeIsTerminal(oNode))            return true;        for (int d = original.firstDaughterOfNode(oNode); original.nodeExists(d); d = original.nextSisterOfNode(d))            if (!checkAncestorFunctionEquivalence(d))                return false;        if (original.nodeIsPolytomous(oNode))            return true;        if (getRoot() == oNode)            return oNode == original.getRoot();        int noPolyAncNode = oNode;        for (int oAncNode = oNode; original.nodeExists(oAncNode); oAncNode = original.motherOfNode(oAncNode), noPolyAncNode = motherOfNode(noPolyAncNode)){            if (oAncNode!=noPolyAncNode) {                if (original.nodeIsPolytomous(oAncNode)){ //skip down extra                    while (nodeExists(noPolyAncNode) && noPolyAncNode != oAncNode)                        noPolyAncNode = motherOfNode(noPolyAncNode);                    if (!nodeExists(noPolyAncNode))                         return false;                }                else                     return false;            }        }        return true;    }	}