/* PDAP:PDTREE package for Mesquite  copyright 2001-2009 P. Midford & W. MaddisonPDAP:PDTREE is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.The web site for PDAP:PDTREE is http://mesquiteproject.org/pdap_mesquite/This source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.pdap.lib;import mesquite.lib.*;import mesquite.cont.lib.*;/** *  * @author peter * created 2001 * */public class UnivariateContrastCalculator extends ContrastCalculator{	    /**      * Constructor for a calculator using univariate data      * @param theTree     * @param observedStates     */    public UnivariateContrastCalculator(Tree theTree, ContinuousDistribution observedStates) {        super();        if (theTree == null || observedStates == null) {            MesquiteMessage.printStackTrace("A null value was passed to the constructor for UnivariateContrastCalculator");            tree = null;            observedStates = null;        }        else {            tree = theTree;            states = observedStates;            numNodes = tree.getNumNodeSpaces();            checkArrays();        }	    }    /**      * this tries to reuse as much memory as possible, while resetting everything      * @param theTree     * @param theDeletions     * @param observedStates     */    public void reinitialize(Tree theTree, boolean[] theDeletions,ContinuousDistribution observedStates) {        tree = theTree; //reinitialize internals        states = observedStates;        numNodes = tree.getNumNodeSpaces();         checkArrays(); // either blank all arrays or allocate new ones if space requirements change    }    /*..................................................................................................................*/    /** fills or updates the internal arrays */    private void checkArrays() {        if (contrasts == null || contrasts.length != numNodes) {            contrasts = new double[numNodes];            rawContrasts = new double[numNodes];            vPrime = new double[numNodes];            x = new double[numNodes];            stdDev = new double[numNodes];            height = new double[numNodes];            rawHeight = new double[numNodes];            weightPassThrough = new double[numNodes];        }        else {            DoubleArray.deassignArray(contrasts);            DoubleArray.deassignArray(rawContrasts);  //should this be zeroArray?            DoubleArray.deassignArray(x);            DoubleArray.deassignArray(vPrime);            DoubleArray.deassignArray(stdDev);            DoubleArray.deassignArray(height);            DoubleArray.deassignArray(rawHeight);            DoubleArray.deassignArray(weightPassThrough);        }    }    /*.................................................................................................................*/    /**     * Calculates contrast 'standard deviations' and adjusted branch lengths.  Note that this code handles missing data and     * calculates standard deviations and v' values by passing branches through nodes where one daughter has missing data     * @param node used for recursive traversal of the tree, should be called with tree.getRoot()     *     */    protected void vCalculation(int node) {        for (int daughter = tree.firstDaughterOfNode(node); tree.nodeExists(daughter); daughter = tree.nextSisterOfNode(daughter))            vCalculation(daughter);        if (tree.nodeIsInternal(node)) {            int left = tree.firstDaughterOfNode(node);            int right = tree.lastDaughterOfNode(node);            if (MesquiteDouble.isCombinable(vPrime[left]) && MesquiteDouble.isCombinable(vPrime[right]))  {// both good                vPrime[node] = branchWeight(node) + (vPrime[left] * vPrime[right]) / (vPrime[left] + vPrime[right]); /*vPrime used temporarily!*/                stdDev[node] = Math.sqrt(vPrime[right] + vPrime[left]);				            }            else if (MesquiteDouble.isCombinable(vPrime[left])) { // only left good                weightPassThrough[node] = branchWeight(left);                //vPrime[left] += branchWeight(node);                vPrime[node] = branchWeight(node)+vPrime[left];                stdDev[node] = MesquiteDouble.unassigned;            }            else if (MesquiteDouble.isCombinable(vPrime[right])){ // only right good                weightPassThrough[node] = branchWeight(right);                //vPrime[right] += branchWeight(node);                vPrime[node] = branchWeight(node) + vPrime[right];                stdDev[node] = MesquiteDouble.unassigned;            }            else { // both bad  - so the whole subtree above this node is dead?                vPrime[node] = MesquiteDouble.unassigned;                stdDev[node] = MesquiteDouble.unassigned;            }        }		        else { // Check that the node actually has data available            if (states != null  &&                     MesquiteDouble.isCombinable(x[node]=states.getState(tree.taxonNumberOfNode(node), 0))) {                  //x[node] = states.getState(tree.taxonNumberOfNode(node), 0);                vPrime[node] = branchWeight(node);            }            else{  //bad data                x[node] = MesquiteDouble.unassigned;                vPrime[node] = MesquiteDouble.unassigned;            }        }    }    /*.................................................................................................................*/    /**     * Calculates reconstructed node values.  Note that this code handles missing data by setting contrast values at      * nodes with daughters with missing data to <code>MesquiteDouble.unassigned</code>.  If one daughter has a node value     * (either a tip value or reconstructed) this will assign that daughter's value as the reconstruction of the node.  Since     * this calculation is a down-pass that's the only alternative to <code>unassigned</code>.     * @param node used for recursive traversal of the tree, should be called with tree.getRoot()     */    protected void xCalculation(int node) {        for (int daughter = tree.firstDaughterOfNode(node); tree.nodeExists(daughter); daughter = tree.nextSisterOfNode(daughter))            xCalculation(daughter);        if (tree.nodeIsInternal(node)) {            int left = tree.firstDaughterOfNode(node);            int right = tree.lastDaughterOfNode(node);            if (MesquiteDouble.isCombinable(x[left]) && MesquiteDouble.isCombinable(x[right])) {  // good contrast                x[node] = (vPrime[right]*x[left] + vPrime[left]*x[right] )/(vPrime[left] +vPrime[right]);                  rawContrasts[node] =(x[left] - x[right]);                contrasts[node] = rawContrasts[node]/stdDev[node];            }            else {                rawContrasts[node] = MesquiteDouble.unassigned;                contrasts[node] = MesquiteDouble.unassigned;                x[node] = MesquiteDouble.unassigned;  // Default unless either one of left or right is good                if(MesquiteDouble.isCombinable(x[right]))                    x[node] = x[right];  // no value from left to average with, so all we can do is propagate down!                if(MesquiteDouble.isCombinable(x[left]))                    x[node] = x[left];  // no value from right to average with, so all we can do is propagate down!            }        }        else {            if (states != null  && MesquiteDouble.isCombinable(states.getState(tree.taxonNumberOfNode(node), 0)))                  x[node] = states.getState(tree.taxonNumberOfNode(node), 0);             else                x[node] = MesquiteDouble.unassigned;            stdDev[node] = MesquiteDouble.unassigned;            contrasts[node] = MesquiteDouble.unassigned;        }    }    /**      * This copies tip values into the x array      * @param node used for recursive traversal of the tree, should be called with tree.getRoot()     * @return the array of tip values, internal node values are set to MesquiteDouble.unassigned      */    public double [] fillTips(int node) {        for (int daughter = tree.firstDaughterOfNode(node); tree.nodeExists(daughter); daughter = tree.nextSisterOfNode(daughter))            fillTips(daughter);        if (tree.nodeIsInternal(node)) {            x[node] = MesquiteDouble.unassigned;        }        else {            x[node] = states.getState(tree.taxonNumberOfNode(node), 0);          }        return x;    }}	