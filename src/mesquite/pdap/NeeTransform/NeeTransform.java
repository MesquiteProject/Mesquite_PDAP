/* PDAP:PDTREE package for Mesquite  copyright 2001-2009 P. Midford & W. MaddisonPDAP:PDTREE is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.The web site for PDAP:PDTREE is http://mesquiteproject.org/pdap_mesquite/This source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.pdap.NeeTransform;/*~~  */import mesquite.lib.*;import mesquite.lib.duties.*;/** ======================================================================== */public class NeeTransform extends BranchLengthsAlterer {    final static double log10 = Math.log(10.0);    double [] depth;    /*.................................................................................................................*/    public boolean startJob(String arguments, Object condition, boolean hiredByName) {        return true;    }    /*.................................................................................................................*/    /**     * Real entry point for the transform - a wrapper around the recursive method doTransform     * which sets all the branch lengths to those dictated by     * Nee's (pers. comm.) arbitrary method.  The distance from the tips     * to the current node is equal to the log10 of the number of tips     * descending from that node.  It is mostly copied from the code for     * Grafen's arbitrary transform -- see GrafenTransform.java     * @param tree the tree to transform     * @param resultString passed in, never filled     * @return returns true because this assumes the calling code is always responsible for notifying listeners of tree     */    public  boolean transformTree(AdjustableTree tree, MesquiteString resultString){        doTransform(tree, tree.getRoot());        return true;    }    /**     * This method sets all the branch lengths to those dictated by     * Nee's (pers. comm.) arbitrary method.  The distance from the tips     * to the current node is equal to the log10 of the number of tips     * descending from that node.  It is mostly copied from the code for     * Grafen's arbitrary transform -- see GrafenTransform.java     * @param tree     * @param root     */    private void doTransform(AdjustableTree tree, int root) {        MesquiteInteger rootCount = new MesquiteInteger();        depth = new double[tree.getNumNodeSpaces()];        neeMe1(tree,root,rootCount);        neeMe2(tree,root);    }    /**     * This procedure computes the depths recursively.     * There are two support functions since DOS PDAP needed to handle polytomies specially.     * @param tree     * @param nd     * @param mothersCount     *      */    private void neeMe1(AdjustableTree tree, int nd, MesquiteInteger mothersCount) {         MesquiteInteger myCounts = new MesquiteInteger(0);        if (!tree.nodeIsInternal(nd)) {            mothersCount.add(1);            // this is a tip, so there is 1 in the subtree            depth[nd] =0;                   //set depth to 0        }        else {            for (int daughter=tree.firstDaughterOfNode(nd); tree.nodeExists(daughter); daughter = tree.nextSisterOfNode(daughter) )                 neeMe1(tree,daughter,myCounts);            mothersCount.add(myCounts.getValue());            depth[nd] = Math.log(myCounts.getValue())/log10; //save log10(tips) as depth        }    }    /**     * This method finishes the transformation by assigning branch lengths.  Since this is a regular     * Mesquite tree, ZLB's shouldn't get special treatment.     * @param tree AdjustableTree to transform     * @param nd int specifying where we are in the tree     */    private void neeMe2(AdjustableTree tree, int nd) {        if (tree.nodeIsInternal(nd)) {            for (int daughter=tree.firstDaughterOfNode(nd); tree.nodeExists(daughter); daughter = tree.nextSisterOfNode(daughter) ) {                 tree.setBranchLength(daughter,depth[nd]-depth[daughter],false);                neeMe2(tree,daughter);            }        }    }    /*.................................................................................................................*/    public String getName() {        return "Branch Lengths Method of Nee";    }    /*.................................................................................................................*/    public String getVersion() {        return "1.15";    }    /*.................................................................................................................*/    public boolean isPrerelease() {        return false;    }    /*................................................................................................................*/    public boolean isSubstantive(){        return true;    }            /*.................................................................................................................*/    public String getAuthors() {        return "Peter E. Midford, Ted Garland Jr., and Wayne P. Maddison";    }    /*.................................................................................................................*/    /** returns an explanation of what the module does.*/    public String getExplanation() {        return ("Adjusts a tree's branch lengths according a method of Nee - The distance from the tips " +        "to the current node is equal to the log10 of the number of tips descending from that node. " );    }}