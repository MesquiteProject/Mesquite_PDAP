/* PDAP:PDTREE package for Mesquite  copyright 2001-2009 P. Midford & W. MaddisonPDAP:PDTREE is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.The web site for PDAP:PDTREE is http://mesquiteproject.org/pdap_mesquite/This source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.pdap.ExpTransformChar;/*~~  */import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.cont.lib.*;import mesquite.lib.table.*;/** ======================================================================== */public class ExpTransformChar extends ContDataAlterer {    static final double maxExp = Math.log(Double.MAX_VALUE);    /*.................................................................................................................*/    public boolean startJob(String arguments, Object condition, boolean hiredByName) {        return true;    }    /** Called to alter data in those cells selected in table*/    public int alterData(CharacterData data, MesquiteTable table,  UndoReference undoReference){        boolean valid=true;        boolean did=false;        if (!(data instanceof ContinuousData))            return ResultCodes.INCOMPATIBLE_DATA;        ContinuousData cData = (ContinuousData)data;        if (table==null && data !=null){            // first check            for (int i=0; i<cData.getNumChars(); i++){                for (int j=0; j<cData.getNumTaxa(); j++) {                    valid = valid && checkCell(cData, i, j);                }            }            // then transform only if all cells are valid            if (valid) {                for (int i=0; i<cData.getNumChars(); i++){                    for (int j=0; j<cData.getNumTaxa(); j++) {                        transformCell(cData, i, j);                        did=true;                    }                }            }        }        else if (table!=null && cData !=null){            if (table.anyCellSelected()) {                // first check                for (int i=0; i<table.getNumColumns(); i++)                    for (int j=0; j<table.getNumRows(); j++)                        if (table.isCellSelected(i,j)) {                            valid = valid && checkCell(cData, i, j);                        }                // then transform only if all selected cells are valid                if (valid) {                    for (int i=0; i<table.getNumColumns(); i++)                        for (int j=0; j<table.getNumRows(); j++)                            if (table.isCellSelected(i,j)) {                                transformCell(cData, i, j);                                did = true;                            }                }            }            else if (table.anyRowSelected()) {                // first check                for (int j=0; j<table.getNumRows(); j++) {                    if (table.isRowSelected(j))                        for (int i=0; i<table.getNumColumns(); i++) {                            valid = valid && checkCell(cData, i, j);                        }                }                // then transform only if all selected cells are valid                if (valid) {                    for (int j=0; j<table.getNumRows(); j++) {                        if (table.isRowSelected(j))                            for (int i=0; i<table.getNumColumns(); i++) {                                transformCell(cData, i, j);                                did = true;                            }                    }                }            }            else if (table.anyColumnSelected()) {                // first check                for (int i=0; i<table.getNumColumns(); i++){                    if (table.isColumnSelected(i))                        for (int j=0; j<table.getNumRows(); j++) {                            valid = valid && checkCell(cData, i, j);                        }                }                // then transform only if all selected cells are valid                if (valid) {                    for (int i=0; i<table.getNumColumns(); i++){                        if (table.isColumnSelected(i))                            for (int j=0; j<table.getNumRows(); j++) {                                transformCell(cData, i, j);                                did=true;                            }                    }                }            }            else {                // first check                for (int i=0; i<cData.getNumChars(); i++){                    for (int j=0; j<cData.getNumTaxa(); j++) {                        valid = valid && checkCell(cData, i, j);                        did=true;                    }                }                // then transform only if all selected cells are valid                if (valid) {                    for (int i=0; i<cData.getNumChars(); i++){                        for (int j=0; j<cData.getNumTaxa(); j++) {                            transformCell(cData, i, j);                            did=true;                        }                    }                }            }        }        if (!valid){            alert("Values were not exponentially transformed because some values were too large.");        }	        return ResultCodes.SUCCEEDED;    }    private boolean checkCell(ContinuousData data, int ic, int it){        int item = 0; //TODO: other items        final double state = data.getState(ic,it, item);        if (MesquiteDouble.isCombinable(state))             return (state<maxExp);        else            return true;  //if not combinable, transformCell ignores it, so should checkCell     }    private void transformCell(ContinuousData data, int ic, int it){        int item = 0; //TODO: other items        final double state = data.getState(ic,it, item);        if (MesquiteDouble.isCombinable(state)) {            data.setState(ic,it, item, Math.exp(state));        }    }    /*.................................................................................................................*/    public String getName() {        return "Exp transform";    }    /*.................................................................................................................*/    public String getVersion() {        return "1.15";    }    /*.................................................................................................................*/    public boolean isPrerelease() {        return false;    }    /** marks the module as doing a substantive calculation - not decorative */    public boolean isSubstantive(){        return true;    }    /*.................................................................................................................*/    public String getAuthors() {        return "Peter E. Midford, Ted Garland Jr., and Wayne P. Maddison";    }    /*.................................................................................................................*/    /** returns an explanation of what the module does.*/    public String getExplanation() {        return "Alters continuous data by exp transforming values." ;    }}