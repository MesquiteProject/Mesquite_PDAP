/* PDAP:PDTREE package for Mesquite  copyright 2001-2010 P. Midford & W. MaddisonPDAP:PDTREE is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.The web site for PDAP:PDTREE is http://mesquiteproject.org/pdap_mesquite/This source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.pdap.DivideChars;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.cont.lib.*;import mesquite.lib.table.*;/** ======================================================================== */public class DivideChars extends ContDataAlterer {	/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, boolean hiredByName) {		return true;	}	/** Called to alter data in those cells selected in table   	 *   @param data CharacterData   	 *   @param table MesquiteTable   	 *   @return boolean - true if data was altered    	 */	public boolean alterData(CharacterData data, MesquiteTable table,  UndoReference undoReference){		boolean valid = true;		boolean did=false;		if (!(data instanceof ContinuousData))			return false;		ContinuousData cData = (ContinuousData)data;		int divisorColumn = MesquiteInteger.queryInteger(null,"Divisor column", "Enter the number of the column to divide by", 2);		if (!MesquiteInteger.isCombinable(divisorColumn) || divisorColumn<0 || divisorColumn>= cData.getNumChars())			return false;		divisorColumn--;       // because these columns are zero-based.		if (table==null && data !=null){			// first check			for (int i=0; i<cData.getNumChars(); i++){				for (int j=0; j<cData.getNumTaxa(); j++) {					valid = valid && checkCell(cData, i, j,divisorColumn);				}			}			// then transform only if all cells are valid			if (valid) {				for (int i=0; i<cData.getNumChars(); i++){					for (int j=0; j<cData.getNumTaxa(); j++) {						transformCell(cData, i, j,divisorColumn);						did=true;					}				}					}		}		else if (table!=null && cData !=null){			if (table.anyCellSelected()) {				// first check				for (int i=0; i<table.getNumColumns(); i++)					for (int j=0; j<table.getNumRows(); j++)						if (table.isCellSelected(i,j)) {							valid = valid && checkCell(cData, i, j,divisorColumn);						}				// then transform only if all cells are valid				if (valid) {					for (int i=0; i<table.getNumColumns(); i++)						for (int j=0; j<table.getNumRows(); j++)							if (table.isCellSelected(i,j)) {								transformCell(cData, i, j,divisorColumn);								did = true;							}				}			}			else if (table.anyRowSelected()) {				// first check				for (int j=0; j<table.getNumRows(); j++) {					if (table.isRowSelected(j))						for (int i=0; i<table.getNumColumns(); i++) {							valid = valid && checkCell(cData, i, j,divisorColumn);						}				}				// then transform only if all cells are valid				if (valid) {					for (int j=0; j<table.getNumRows(); j++) {						if (table.isRowSelected(j))							for (int i=0; i<table.getNumColumns(); i++) {								transformCell(cData, i, j,divisorColumn);								did = true;							}					}				}			}			else if (table.anyColumnSelected()) {				// first check				for (int i=0; i<table.getNumColumns(); i++){					if (table.isColumnSelected(i))						for (int j=0; j<table.getNumRows(); j++) {							valid = valid && checkCell(cData, i, j,divisorColumn);						}				}				// then transform only if all cells are valid				if (valid) {					for (int i=0; i<table.getNumColumns(); i++){						if (table.isColumnSelected(i))							for (int j=0; j<table.getNumRows(); j++) {								transformCell(cData, i, j,divisorColumn);								did=true;							}					}				}			}			else {				// first check				for (int i=0; i<cData.getNumChars(); i++){					for (int j=0; j<cData.getNumTaxa(); j++) {						valid = valid && checkCell(cData, i, j,divisorColumn);					}				}				// then transform only if all cells are valid				if (valid) {					for (int i=0; i<cData.getNumChars(); i++){						for (int j=0; j<cData.getNumTaxa(); j++) {							transformCell(cData, i, j,divisorColumn);							did=true;						}					}				}			}		}		if (!valid){			alert("Values were not divided because some divisors were zero.");		}			return did;	}	/** Called to check that the data in a cell isCombinable before applying a transform */	private boolean checkCell(ContinuousData data, int ic, int it,int jc){		int item = 0; //TODO: other items		double divisor = data.getState(jc,it,item);		if  (MesquiteDouble.isCombinable(divisor)) 			return (divisor != 0);		else			return true;  //if not combinable, transformCell ignores it, so should checkCell 	}	/** Does the transformation on a single cell */	private void transformCell(ContinuousData data, int ic, int it,int jc){		int item = 0; //TODO: other items		double state = data.getState(ic,it, item);		double divisor = data.getState(jc,it,item);		if ((MesquiteDouble.isCombinable(state)) && 				(MesquiteDouble.isCombinable(divisor))) {			data.setState(ic,it, item, state/divisor);		}	}	/*.................................................................................................................*/	/** returns a descriptive name for the module 	    @return String */	public String getName() {		return "Divide selected data by a column";	}	/*.................................................................................................................*/	/** returns a version number string for the module	    @return String */	public String getVersion() {		return "1.12";	}	/*.................................................................................................................*/	/** marks the module as NOT being a prerelease 	    @return boolean - constant false*/	public boolean isPrerelease() {		return false;	}     /*................................................................................................................*/    public boolean isSubstantive(){        return true;    }        	/*.................................................................................................................*/	/** returns an explanation of what the module does. 	 *  @return String 	 */	public String getExplanation() {		return "Alters continuous data by dividing each selected value by a value in the same row in a designated column." ;	}}