/* PDAP:PDTREE package for Mesquite  copyright 2001-2009 P. Midford & W. MaddisonPDAP:PDTREE is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.The web site for PDAP:PDTREE is http://mesquiteproject.org/pdap_mesquite/This source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.pdap.ScatterOriDiagnostics;/*~~  */import java.awt.*;import java.util.*;import mesquite.cont.lib.ContinuousDistribution;import mesquite.lib.*;import mesquite.pdap.lib.*;public class ScatterOriDiagnostics extends ScatterRegisterableAsst  {    public void getEmployeeNeeds(){  //This gets called on startup to harvest information; override this and inside, call registerEmployeeNeed        EmployeeNeed e = registerEmployeeNeed(PDAP2CTStatPakSource.class, getName() + "  needs a method to calculate correlations.",        "The method to calculate correlations is selected initially");        EmployeeNeed e1 = registerEmployeeNeed(PDAPFileReporter.class, getName() + "  needs a method to write FIC reports.",        "The method to write FIC reports is selected initially");    }       // Text to display explaining FIC columns    static final private String FIC_COLUMN_DESCRIPTION =            "FIC files contain the following columns:\n\n" +            " 1.  Name of Contrast as Node - Node (e.g., 'Tm - Ta')\n" +            " 2.  Name of Node at Base of Contrast\n" +            " 3.  Unstandardized Contrast for Trait 1\n" +            " 4.  Unstandardized Contrast for Trait 2\n" +            " 5.  Standard Deviation of Contrast\n" +            "     = square root of sum of corrected branch lengths\n" +            " 6.  Nodal Value for Trait 1\n" +            " 7.  Nodal Value for Trait 2\n" +            " 8.  Uncorrected Height of Base Node from Root of Tree\n" +            " 9.  Corrected Height of Base Node from Root of Tree\n" +            "         (as used in screens 5, 6, 7, 8, and 11)\n" +            "10.  Average Uncorrected Height of Daughter Nodes\n" +            "11.  Average Corrected Height of Daughter Nodes\n" +            "12.  Name of First Daughter Branch (Descendant-Ancestor)\n" +            "13.  Corrected Length of First Daughter Branch\n" +            "14.  Name of Second Daughter Branch (Descendant-Ancestor)\n" +            "15.  Corrected Length of Second Daughter Branch\n";    // String constants for module commands    static final private String TOGGLESHOWLINES_CMD = "toggleShowLines";    static final private String WRITEFIC_CMD = "writeFIC";    static final private String TOGGLEFICINPANE_CMD = "toggleFICinPane";    static final private String GETCORRCOEFF_CMD = "getCorrelationCoefficient";    static final private String GETPVALUE_CMD = "getPValue";    static final private String SHOWFIC_CMD = "showFIC";    static final private String SETDFREDUCTION_CMD = "setDFReduction";    static final private String SETVERBOSEQUERYMODE_CMD = "setVerboseQueryMode";    static final private String SETIGNOREROOTTRITOMIES_CMD = "setIgnoreRootTritomies";        private final MesquiteInteger zeroPos = new MesquiteInteger(0);        private ArrayList extras;    private PDAP2CTStatPakSource sps;    private MesquiteBoolean showLines;    private PDAPFileReporter FICReportTask;    private PDAPTreeWinAsstC chartModule;    private MesquiteBoolean paneHasFICData;    private MesquiteBoolean spaceConvertFICNames;    protected PDAP2CTStatPak myStats = null;    public boolean startJob(String arguments, Object condition, boolean hiredByName) {        extras = new ArrayList();        showLines = new MesquiteBoolean(true);        paneHasFICData = new MesquiteBoolean(false);        spaceConvertFICNames = new MesquiteBoolean(true);        addCheckMenuItem(null, "Show Regression Lines", makeCommand(TOGGLESHOWLINES_CMD,  (Commandable)this), showLines);        addMenuItem(null, "Generate File of Independent Contrasts (FIC)", makeCommand(WRITEFIC_CMD, (Commandable)this));        addCheckMenuItem(null, "Show data from File of Independent Contrasts in text pane", makeCommand(TOGGLEFICINPANE_CMD,(Commandable)this),paneHasFICData);        addMenuItem(null,"Show columns in File of Independent Contrasts (FIC)",makeCommand(SHOWFIC_CMD,(Commandable)this));        addMenuItem(null, "Root Calculation Query Mode...", makeCommand(SETVERBOSEQUERYMODE_CMD,  (Commandable)this));        addMenuItem(null, "Set Polytomy DF Reduction...", makeCommand(SETDFREDUCTION_CMD,  (Commandable)this));         addMenuItem("Ignore Root Tritomies...", makeCommand(SETIGNOREROOTTRITOMIES_CMD, (Commandable)this));        sps = (PDAP2CTStatPakSource)hireNamedEmployee(PDAP2CTStatPakSource.class, "#SPOriDiagnostics");        if (sps == null)            return sorry(getName() + " couldn't start because no source of correlations obtained.");               FICReportTask = (PDAPFileReporter)hireNamedEmployee(PDAPFileReporter.class, "#FICReport");        if (FICReportTask == null)            return sorry(getName() + " couldn't start because no FIC reporter module obtained.");               return true;    }    /*.................................................................................................................*/	    public String getLegendText(){        String s = "";        if (myStats != null){            String b = myStats.getLegendText();            if (!StringUtil.blank(b))                s +=  b + "\n";        }        s += "Regression lines through origin: \n" +        "    Black is ordinary least squares (OLS) \n" +        "    Green is major axis (MA) \n" +        "    Red is reduced major axis \n";        return s;    }        public boolean suppliesWritableResults(){        return (sps.getStatPak() != null);    }    public Object getResultsHeading() {        return getName();    }    /*-----------------------------------------*/    /**     * @return computed values with descriptive strings     */    public MesquiteNumber[] getWritableResults() {        if (myStats == null)            myStats = sps.getStatPak();        return myStats.getWritableResults();    }    /*-----------------------------------------*/    public Snapshot getSnapshot(MesquiteFile file) {        Snapshot temp = new Snapshot();        temp.addLine("toggleShowLines " + showLines.toOffOnString());        return temp;    }    /*.................................................................................................................*/    /**     * Dispatches a script command	 * @param String commandName	 * @param String argments	 * @param CommandChecker checker     */    public Object doCommand(String commandName, String arguments, CommandChecker checker) {        final Class thisClass = this.getClass();        if (checker.compare(thisClass, "Sets whether or not the regression line is shown", "[on = show; off]", commandName, TOGGLESHOWLINES_CMD)) {            showLines.toggleValue(parser.getFirstToken(arguments));            parametersChanged();        }        else if (checker.compare(thisClass, "Generate File of Independent Contrasts (FIC)",null,commandName,WRITEFIC_CMD)) {            if (chartModule!=null) {            	MesquiteFile FICfile = new MesquiteFile();            	FICReportTask.writeReport(FICfile,chartModule.getObserved1(),chartModule.getObserved2(),chartModule.getTree(),arguments);	            }        }        else if (checker.compare(thisClass,"Sets whether or not data from File of Independent Contrasts is shown in the text pane","[on = show; off]",commandName,TOGGLEFICINPANE_CMD)) {            paneHasFICData.toggleValue(parser.getFirstToken(arguments));            if (paneHasFICData.getValue()){                spaceConvertFICNames.setValue(AlertDialog.query(chartModule.containerOfModule(),"Convert Spaces?", "Convert Spaces in node names to underscores (_); useful if pasting into Excel","Convert","Leave Unchanged"));            }            parametersChanged();        }	        else if (checker.compare(thisClass, "Gets correl coef", null, commandName, GETCORRCOEFF_CMD)) {            if (extras.size() == 1){                SODExtra extra = (SODExtra)extras.get(0);                return new MesquiteNumber(extra.getValue(commandName));            }        }        else if (checker.compare(thisClass, "Gets p value", null, commandName, GETPVALUE_CMD)) {            if (extras.size() == 1){                SODExtra extra = (SODExtra)extras.get(0);                return new MesquiteNumber(extra.getValue(commandName));            }        }        else if (checker.compare(thisClass, "Show columns in File of Independent Contrasts (FIC)",null,commandName,SHOWFIC_CMD)) {            AlertDialog.notice(null,"FIC Columns",FIC_COLUMN_DESCRIPTION);        }        else if (checker.compare(thisClass,"Sets the number of DF's reduced because of polytomies","[number of dof]", commandName, SETDFREDUCTION_CMD)) {            if (myStats == null){               MesquiteMessage.warnProgrammer("ScatterOriDiagnostics statPak should not be null");               return null;            }            int dfReduction = MesquiteInteger.fromFirstToken(arguments, zeroPos);            if (!MesquiteInteger.isCombinable(dfReduction))                chartModule.queryDFReduce(myStats, true);            else                chartModule.setDFReduction(dfReduction);            chartModule.setDFQueryDone(true);            myStats.setDFReduction(chartModule.getDFReduction());            parametersChanged();        }        else if (checker.compare(thisClass,"Sets the query mode to verbose or not", "[on/off]",commandName, SETVERBOSEQUERYMODE_CMD)) {            if (StringUtil.blank(arguments))                 chartModule.queryVerboseQueryMode();            else                chartModule.toggleVerboseQueryMode(parser.getFirstToken(arguments));        }        else if (checker.compare(thisClass,"Sets whether to ignore a tritomy at the root ", "[boolean]",commandName, SETIGNOREROOTTRITOMIES_CMD)){            if (StringUtil.blank(arguments)) //not a menu command..                chartModule.queryIgnoreRootTritomies();            else{                String s = parser.getFirstToken(arguments);                chartModule.setIgnoreRootTritomies("true".equalsIgnoreCase(s));            }             myStats.setIgnoreRootTritomies(chartModule.getIgnoreRootTritomies());        }        else            return  super.doCommand(commandName, arguments, checker);        return null;    }    /*-----------------------------------------*/    public boolean canHireMoreThanOnce () {        return false;    }    /*-----------------------------------------*/    public void setChartModule(PDAPTreeWinAsstC module){        chartModule = module;    }        public PDAPTreeWinAsstC getChartModule(){        return chartModule;    }        /**     *      * gets observed from the chart module; count internal nodes, ZLBs; ask about df reduce     */    protected void updateStats(){        if (chartModule != null){            Tree tree = chartModule.getTree();            int root = tree.getRoot();            if (myStats == null){                myStats = sps.getStatPak();                myStats.setDFReduction(0);            }            //pass the tree 'context' into the statPak so it can properly handle missing data            myStats.setTree(tree);            myStats.setObserved1((ContinuousDistribution)chartModule.getObserved1());            myStats.setObserved2((ContinuousDistribution)chartModule.getObserved2());            myStats.countInternalNodes(tree, root); // count the internal nodes,            // to set number            myStats.setIgnoreRootTritomies(chartModule.getIgnoreRootTritomies());            int zlb = ((NoPolyTree)tree).countZLBs(myStats.getIgnoreRootTritomies()); // Zero-Length-Branches are what PDAP calls "polytomies"; count to            if (!MesquiteThread.isScripting()){                if (!chartModule.getDFQueryDone() &&                         ((zlb > 0) || chartModule.getVerboseQueryMode())){                    chartModule.queryDFReduce(myStats, true);                    myStats.setDFReduction(chartModule.getDFReduction());                    chartModule.setDFQueryDone(true);                }            }            else myStats.setDFReduction(chartModule.getDFReduction());       }    }        /**     *      * @return contains summary text for diagnostics chart     */    protected String getTextSummary(){        if (myStats!=null) {            if (paneHasFICData.getValue()) {                FICReportTask.pushConvertSpaces(spaceConvertFICNames.getValue());                String tmp = FICReportTask.reportToString(chartModule.getObserved1(),                        chartModule.getObserved2(),                        chartModule.getTree(),                        "\n",                        " "                        );                  FICReportTask.popConvertSpaces();                return tmp + "\n\n" + myStats.flst();            }            else                return myStats.flst();        }               else return "";    }        /**     * This draws the colored line segments for the three different regression models that will     * be dumped below.  Unlike ScatterRegDiagnostics, these should all go through the origin, so     * this method starts the lines at the origin, rather than min[x], which should be positive,     * (or rarely zero in real data sets) since contrasts are positivized.     * @param g     * @param chart     */    protected void getDrawing(Graphics g, MesquiteChart chart){        if (myStats==null || !showLines.getValue())            return;        final double ls = myStats.getLeastSquaresSlope();        if (!MesquiteDouble.isCombinable(ls))            return;        final double min0 = myStats.getMin(0);        final double max0 = myStats.getMax(0);        final double rma = myStats.getReducedMajorAxis();        final double ma = myStats.getMajorAxis();        final Charter c = chart.getCharter();        final int startX = c.xToPixel(0,chart);             final int startYOLS =  c.yToPixel(ls*min0,chart);        final int endX = c.xToPixel(max0,chart);        final int endYOLS = c.yToPixel(ls*max0,chart);        final int startYRMA =  c.yToPixel(rma*min0,chart);        final int endYRMA = c.yToPixel(rma*max0,chart);        final int startYMA =  c.yToPixel(ma*min0,chart);        final int endYMA = c.yToPixel(ma*max0,chart);        final int extraLineWidth = 1;        g.setColor(Color.red);        g.drawLine(startX, startYRMA,endX,endYRMA);        // conditional handles drawing thicker lines        if (Math.abs(endYRMA-startYRMA)>(endX-startX))   // abs(slope) > 1            g.drawLine(startX+extraLineWidth,startYRMA,endX+extraLineWidth,endYRMA);        else                g.drawLine(startX,startYRMA+extraLineWidth,endX,endYRMA+extraLineWidth);        g.setColor(Color.green);        g.drawLine(startX,startYMA,endX,endYMA);        // conditional handles drawing thicker lines        if (Math.abs(endYMA-startYMA)>(endX-startX))   // abs(slope) > 1            g.drawLine(startX+extraLineWidth,startYMA,endX+extraLineWidth,endYMA);        else                g.drawLine(startX,startYMA+extraLineWidth,endX,endYMA+extraLineWidth);        // Draw the OLS line last so if it and the MA line are "almost" the same, the OLS line "wins."        g.setColor(Color.black);        g.drawLine(startX, startYOLS,endX,endYOLS);        if (Math.abs(endYOLS-startYOLS)>(endX-startX))   // abs(slope) > 1            g.drawLine(startX+extraLineWidth,startYOLS,endX+extraLineWidth,endYOLS);        else                g.drawLine(startX,startYOLS+extraLineWidth,endX,endYOLS+extraLineWidth);    }            /**      * Factory method for creating and initializing ChartExtras     * @parm chart     * @return a new ChartExtra initialized with chart     */    public ChartExtra createExtra(MesquiteChart chart){        ChartExtra s =  new SODExtra(this, chart);        extras.add(s);        return s;    }    /** */    public void endJob(){        if (extras!=null){            for (int i=0; i<extras.size(); i++){                if (extras.get(i) != null){                    ChartExtra extra = (ChartExtra)extras.get(i);                    extra.turnOff();                }                else                    MesquiteMessage.warnProgrammer("Found a null entry in the list of chartExtras of the ScatterOriDiagnostics while ending");            }        }        super.endJob();    }    /*.................................................................................................................*/    public String getName(){        return "Scattergram Diagnostics using Regression through the Origin";    }    /*.................................................................................................................*/    public String getAuthors() {        return "Peter E. Midford, Ted Garland Jr., and Wayne P. Maddison" ;    }    /*.................................................................................................................*/    public String getVersion() {        return "1.15";    }    /** returns an explanation of what the module does.*/    public String getExplanation() {        return "Calculates statistics for scattergram regression lines forced through the origin." ;    }    /*.................................................................................................................*/    public boolean isPrerelease() {        return false;    }}/** *  * @author peter * created Aug 28, 2009 * */class SODExtra extends ChartExtra {    // first create and initialize the new rootStatPak    PDAP2CTStatPak oldStats = null;    Tree lastTree;    long lastVersion;    ScatterOriDiagnostics ownerModule;    public SODExtra(ScatterOriDiagnostics ownerModule, MesquiteChart chart){        super(ownerModule, chart);        this.ownerModule = ownerModule;    }    private PDAP2CTStatPak getStats(){        return ownerModule.myStats;    }        /**Do any calculations needed*/    public boolean doCalculations(){        if (chart!=null && ownerModule.getChartModule() != null){/*          Tree tree = ownerModule.chartModule.getTree();            if (tree != lastTree){                lastTree = tree;                lastVersion = tree.getVersionNumber();                ownerModule.chartModule.setDFQueryDone(false);            }            else if (lastVersion != tree.getVersionNumber()){                lastVersion = tree.getVersionNumber();                ownerModule.chartModule.setDFQueryDone(false);                            }*/                         boolean wasConstrained = chart.isMaximumXConstrained() ||                 chart.isMaximumYConstrained() ||                 chart.isMinimumXConstrained() ||                 chart.isMinimumYConstrained();            if (wasConstrained){                chart.deConstrainMaximumX();                chart.deConstrainMaximumY();                chart.deConstrainMinimumX();                chart.deConstrainMinimumY();            }            //gets observed from the chart module; count internal nodes, ZLBs;             //ask about df reduce            ownerModule.updateStats();            //does all the other calculations            boolean munch = getStats().doCalculations(chart.getXArray(), chart.getYArray(), chart);            if (munch)                chart.munch();            return wasConstrained;        }        return false;    }    /**	@param String commandName specifies the field from the statPak to return	@return double the value requested or MesquiteDouble.unassigned     */    public double getValue(String commandName) {        if (commandName.equals("getCorrelationCoefficient")) {            return getStats().getCorrelationCoefficient();        }        if (commandName.equals("getPValue")) {            return getStats().getPValue();        }        else return MesquiteDouble.unassigned;    }    /**     * This draws the colored line segments for the three different regression models that will     * be dumped below.  Unlike ScatterRegDiagnostics, these should all go through the origin, so     * this method starts the lines at the origin, rather than min[x], which is should be positive,     * since contrasts are positivized (and should rarely be zero).     * @param g      */    public void drawOnChart(Graphics g){        ownerModule.getDrawing(g,chart);    }    /**print on the chart*/    public void printOnChart(Graphics g){        drawOnChart(g);    }    public String writeOnChart(){        return ownerModule.getTextSummary();    }    /**to inform ChartExtra that cursor has just entered point*/    public void cursorEnterPoint(int point, int exactPoint, Graphics g){        //Debugg.println("enter point " + point);    }    /**to inform ChartExtra that cursor has just exited point*/    public void cursorExitPoint(int point, int exactPoint, Graphics g){        //Debugg.println("exit point " + point);    }    /**to inform ChartExtra that cursor has just touched point*/    public void cursorTouchPoint(int point, int exactPoint, Graphics g){        //Debugg.println("touch point " + point);    }}