/* PDAP:PDTREE package for Mesquite  copyright 2001-2009 P. Midford & W. MaddisonPDAP:PDTREE is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.The web site for PDAP:PDTREE is http://mesquiteproject.org/pdap_mesquite/This source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.pdap.ScatterResXDiagnostics;/*~~  */import java.awt.*;import java.util.*;import mesquite.lib.*;import mesquite.lib.ui.ChartExtra;import mesquite.lib.ui.Charter;import mesquite.lib.ui.MesquiteChart;import mesquite.pdap.lib.*;/** * This class exists to support PDAP diagnostic screen 10, which assumes the * "true" mean of the contrasts (on the X-axis) is zero, and calculates  * variances and other statistics accordingly * @author Peter E. Midford * created 2001 * */public class ScatterResXDiagnostics extends PDAPScatterAsst  {    private Vector<ChartExtra> extras;    /**     * hires the assistant and initializes the extras field       @return true (always)     */    public boolean startJob(String arguments, Object condition, boolean hiredByName) {        extras = new Vector<ChartExtra>();        return true;    }    /**     * Returns an empty legend     * @return an empty string     */    public String getLegendText(){        return "";  //TODO make this legend say something    }    /**     *      * @return true if extras (which will provide results) are available     */    public boolean suppliesWritableResults(){        return (extras != null);  //TODO is this sufficient?    }    /**     * this returns a title for the results     * @return the name     */    public Object getResultsHeading() {        return getName();    }    /**     * @return computed values with descriptive strings     */    public MesquiteNumber[] getWritableResults() {        if (extras != null) {            SRXDExtra extra = (SRXDExtra)extras.elementAt(0);            extra.doCalculations();            return extra.getWritableResults();        }        else            return null;    }    /**     * This returns false, because there should only be one of these per chart     * @return always false      */    public boolean canHireMoreThanOnce () {        return false;    }    /**     * This shouldn't appear as an option - it is always associated with a PDAP chart     * @return always false     */    public boolean getUserChooseable(){        return false;    }    /**     * Create an extra and add it to the extras list     * @param chart passed to the constructor for ChartExtras     */    public ChartExtra createExtra(MesquiteChart chart){        final ChartExtra s =  new SRXDExtra(this, chart);        extras.addElement(s);        return s;    }    public String getName(){        return "Scattergram Diagnostics for residuals vs. contrasts";    }    public String getExplanation() {        return "Calculates summary statistics for a plot of contrast residuals against x-value contrasts.";    }    /*.................................................................................................................*/    public String getAuthors() {        return "Peter E. Midford, Ted Garland Jr., and Wayne P. Maddison" ;    }    /*.................................................................................................................*/    /** returns module version */    public String getVersion() {        return "1.15";    }    /*.................................................................................................................*/    public boolean isPrerelease() {        return false;    }    /*.................................................................................................................*/    /**     * Cleanup when quiting or fired (sort of a destructor method)     */    public void endJob(){        if (extras != null) {            for (int i=0; i<extras.size(); i++){                if (extras.get(i) != null){                    ChartExtra extra = (ChartExtra)extras.elementAt(i);                    extra.turnOff();                }                else                    MesquiteMessage.warnProgrammer("Found a null entry in the list of chartExtras of the ScatterResXDiagnostics while ending");            }        }        super.endJob();    }} //class ScatterResXDiagnosticsclass SRXDExtra extends ChartExtra {    ResidStatPak myStats = null;    public SRXDExtra(MesquiteModule ownerModule, MesquiteChart chart){        super(ownerModule, chart);    }    /**Do any calculations needed*/    public boolean doCalculations(){        if (chart!=null){            if (chart.isMinimumYConstrained() || chart.isMaximumYConstrained()){                chart.deConstrainMinimumX();                chart.deConstrainMaximumX();                chart.deConstrainMinimumY();                chart.deConstrainMaximumY();            }            if (myStats == null)                myStats = new ResidStatPak();                boolean munch = myStats.doCalculations(chart.getXArray(), chart.getYArray(), chart);            if (munch)                chart.munch();			        }        return false;    }    protected MesquiteNumber[] getWritableResults() {        if (myStats == null)            myStats = new ResidStatPak();        return myStats.getWritableResults();    }    /**     * Call the statpak to draw on the chart.     * @param g represents window for drawing     */     public void drawOnChart(Graphics g){        if (myStats!=null)            myStats.drawOnChart(g, chart);    }    /**     * print on the chart - pass through for drawOnChart     */     public void printOnChart(Graphics g){        drawOnChart(g);    }    /**     * calls the statpak method to write to the text window     */    public String writeOnChart(){        return myStats.flst();		    }    /**to inform ChartExtra that cursor has just entered point*/    public void cursorEnterPoint(int point, int exactPoint, Graphics g){        //Debugg.println("enter point " + point);    }    /**to inform ChartExtra that cursor has just exited point*/    public void cursorExitPoint(int point, int exactPoint, Graphics g){        //Debugg.println("exit point " + point);    }    /**to inform ChartExtra that cursor has just touched point*/    public void cursorTouchPoint(int point, int exactPoint, Graphics g){        //Debugg.println("touch point " + point);    }    /**     * This is a simplified statPak for the residuals screen (10)     * @author Peter E. Midford     * last update: September 16, 2009     *     */    class ResidStatPak extends PDAPStatPak{        double     meany;      // only for y variable        double     cov;        double     corr;        /**         * Constructor sets initial values, several inherited fields are overwritten                 */        protected ResidStatPak(){            min = new double[]  {MesquiteInteger.infinite , MesquiteInteger.infinite};            max = new double[] { MesquiteInteger.negInfinite, MesquiteInteger.negInfinite};            variance = new double[] {0.0, 0.0};            meany = 0.0;            number = 0;        }        /**         *  This is the main calculating procedure          * @param xValues contrasts in first trait         * @param yValues residual values         * @param chart throw-away parameter         */         public boolean doCalculations(NumberArray xValues, NumberArray yValues, MesquiteChart chart){            number = 0;            min[0] = MesquiteInteger.infinite;            min[1] = MesquiteInteger.infinite;            max[0] = MesquiteInteger.negInfinite;            max[1] = MesquiteInteger.negInfinite;            variance[0] = 0.0;            variance[1]  = 0.0;            corr = 0.0;            meany = 0.0;            getBounds(xValues,yValues);            getMean(yValues, xValues);   // xValues not calculated, just used for flagging bad y values.            meany /= number;            getVars(xValues,yValues);            variance[0] /= number-1;            variance[1] /= number-1;            corr /= number-1;            cov = corr;            if ((variance[0] != 0) && (variance[1] != 0))                corr = corr/Math.sqrt(variance[0]*variance[1]);            else                corr = 0;            return false;        }        /**          *          * @param data0 array of trait values for the x axis         * @param data1 array of residuals(?) for the y axis          */        //since min and max are zero based, maybe the names data0 and data1 will be less confusing        public void getBounds(NumberArray data0, NumberArray data1){            for (int i = 0; i < data0.getSize(); i++)	                if (data0.isCombinable(i) && data1.isCombinable(i)) {                    number++;                    if (data0.getDouble(i) > max[0])                        max[0] = data0.getDouble(i);                    if (data1.getDouble(i) > max[1])                        max[1] = data1.getDouble(i);                    if (data0.getDouble(i) < min[0])                        min[0] = data0.getDouble(i);                    if (data1.getDouble(i) < min[1])                        min[1] = data1.getDouble(i);                }        }        /** Dummy */        public double getPValue() {            return 0.0;  // no stats here (yet)        }        /** Calculate the mean of the y values (contrast residuals)          *  @param: NumberArray yData          */        public void getMean(NumberArray yData, NumberArray xData){            for (int i = 0; i < yData.getSize(); i++)                if (yData.isCombinable(i) && xData.isCombinable(i))  // If x is bad, so is y, so don't count it                     meany += yData.getDouble(i);        }        /**          * This method calculates the variances (honoring the assumption that mean(x) = 0)         * @param: NumberArray data0         * @param: NumberArray data1          */        public void getVars(NumberArray data0, NumberArray data1) {            for (int i = 0; i < data0.getSize(); i++)                if (data0.isCombinable(i) && data1.isCombinable(i)) {                    double dev0 = data0.getDouble(i);                    double dev1 = data1.getDouble(i)-meany;    // y values have a real mean                    variance[0] += dev0*dev0;                    variance[1] += dev1*dev1;                    corr += dev0*dev1;                }        }        /*............................................................*/        /** This method returns the string that is displayed on the bottom of the window          *  @return summary statistics string for Mesquite text pane         */        public String flst() {            StringBuffer results = new StringBuffer(500);            results.append("Summary statistics for residuals, which assume a true mean of zero.\n\n");            results.append("Number of contrasts: " + number);            results.append("\nMinimum of X,Y coordinates: " + min[0] + ", " + min[1]);            results.append("\nMaximum of X,Y coordinates: " + max[0] + ", " + max[1]);            results.append("\nMean of X,Y coordinates: zero, " + meany);            results.append("\nVariance of X,Y coordinates: " + variance[0] + ", " + variance[1]);            results.append("\nCovariance: " + cov);            results.append("\nPearson Product-Moment Correlation Coefficient: " + corr + "\n");            return results.toString();        }        /**         * @return array of Mesquite numbers containing summary results         */        public MesquiteNumber[] getWritableResults() {            if (writableResults == null){                writableResults = new MesquiteNumber[10];                writableResults[0] = new MesquiteNumber();                writableResults[0].setName("Number of independent contrasts");                writableResults[0].setValue(MesquiteInteger.unassigned);                writableResults[1] = new MesquiteNumber();                writableResults[1].setName("Minimum X");                writableResults[1].setValue(MesquiteInteger.unassigned);                writableResults[2] = new MesquiteNumber();                writableResults[2].setName("Minimum Y");                writableResults[2].setValue(MesquiteInteger.unassigned);                writableResults[3] = new MesquiteNumber();                writableResults[3].setName("Maximum X");                writableResults[3].setValue(MesquiteInteger.unassigned);                writableResults[4] = new MesquiteNumber();                writableResults[4].setName("Maximum Y");                writableResults[4].setValue(MesquiteInteger.unassigned);                writableResults[5] = new MesquiteNumber();                writableResults[5].setName("Mean Y");                writableResults[5].setValue(MesquiteInteger.unassigned);                writableResults[6] = new MesquiteNumber();                writableResults[6].setName("Variance X");                writableResults[6].setValue(MesquiteInteger.unassigned);                writableResults[7] = new MesquiteNumber();                writableResults[7].setName("Variance Y");                writableResults[7].setValue(MesquiteInteger.unassigned);                writableResults[8] = new MesquiteNumber();                writableResults[8].setName("Covariance" );                writableResults[8].setValue(MesquiteInteger.unassigned);                writableResults[9] = new MesquiteNumber();                writableResults[9].setName("Pearson Product-Moment Correlation Coefficient");                writableResults[9].setValue(MesquiteInteger.unassigned);            }            if (MesquiteDouble.isCombinable(corr)){                writableResults[0].setValue(number);                writableResults[1].setValue(min[0]);                writableResults[2].setValue(min[1]);                writableResults[3].setValue(max[0]);                writableResults[4].setValue(max[1]);                writableResults[5].setValue(meany);                writableResults[6].setValue(variance[0]);                writableResults[7].setValue(variance[1]);                writableResults[8].setValue(cov);                writableResults[9].setValue(corr);            }            return writableResults;        }        /** This method returns the string for the legend window.         *  @return String the legend string for this window          */	        public String getLegendText() {            StringBuffer results = new StringBuffer(100);            results.append("Number of contrasts: " + number);            results.append("\nPearson Product-Moment Correlation Coefficient: " + corr + "\n");            return results.toString();        }        /**         * draw on the chart         * @param g represents window for drawing         * @param chart represents scaling for chart         */        public void drawOnChart(Graphics g, MesquiteChart chart){            Charter c = chart.getCharter();            int startX = c.xToPixel(min[0],chart);            int startY =  c.yToPixel(0,chart);            int endX = c.xToPixel(max[0],chart);            int endY = c.yToPixel(0,chart);            g.setColor(Color.black);            g.drawLine(startX, startY,endX,endY);            // insert code for thicker lines here        }    }}