/* PDAP:PDTREE package for Mesquite  copyright 2001-2009 P. Midford & W. MaddisonPDAP:PDTREE is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.The web site for PDAP:PDTREE is http://mesquiteproject.org/pdap_mesquite/This source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.pdap.RaiseStatesToPowerChar;/*~~  */import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.cont.lib.*;import mesquite.lib.table.*;/** ======================================================================== */public class RaiseStatesToPowerChar extends ContDataAlterer {    static final double maxExp = Math.log(Double.MAX_VALUE);    private double savedPower = 1.0;    /*.................................................................................................................*/    public boolean startJob(String arguments, Object condition, boolean hiredByName) {        return true;    }    /** Called to alter data in those cells selected in table*/    public boolean alterData(CharacterData data, MesquiteTable table,  UndoReference undoReference){        boolean did=false;        boolean valid=true;        if (!(data instanceof ContinuousData))            return false;        final double power = MesquiteDouble.queryDouble(containerOfModule(), "Raise to Power", "Raise values in matrix to power:", savedPower);        if (MesquiteDouble.isCombinable(power))            savedPower = power;        else            return false;        ContinuousData cData = (ContinuousData)data;        UndoInstructions undoInstructions = null;        if (table==null && data !=null){            // first check            for (int i=0; i<cData.getNumChars(); i++){                for (int j=0; j<cData.getNumTaxa(); j++) {                    valid = valid && checkCell(cData, i, j, power);                }            }            // then transform only if all cells are valid            if (valid) {                undoInstructions = data.getUndoInstructionsAllData();                for (int i=0; i<cData.getNumChars(); i++){                    for (int j=0; j<cData.getNumTaxa(); j++) {                        transformCell(cData, i, j, power);                        did=true;                    }                }            }        }        else if (table!=null && cData !=null){            if (table.anyCellSelected()) {                // first check                for (int i=0; i<table.getNumColumns(); i++)                    for (int j=0; j<table.getNumRows(); j++)                        if (table.isCellSelected(i,j)) {                            valid = valid && checkCell(cData, i, j, power);                        }                // then transform only if all selected cells are valid                if (valid) {                    undoInstructions = data.getUndoInstructionsAllData();                    for (int i=0; i<table.getNumColumns(); i++)                        for (int j=0; j<table.getNumRows(); j++)                            if (table.isCellSelected(i,j)) {                                transformCell(cData, i, j, power);                                did = true;                            }                }            }            else if (table.anyRowSelected()) {                // first check                for (int j=0; j<table.getNumRows(); j++) {                    if (table.isRowSelected(j))                        for (int i=0; i<table.getNumColumns(); i++) {                            valid = valid && checkCell(cData, i, j, power);                        }                }                // then transform only if all selected cells are valid                if (valid) {                    undoInstructions = data.getUndoInstructionsAllData();                    for (int j=0; j<table.getNumRows(); j++) {                        if (table.isRowSelected(j))                            for (int i=0; i<table.getNumColumns(); i++) {                                transformCell(cData, i, j, power);                                did = true;                            }                    }                }            }            else if (table.anyColumnSelected()) {                // first check                for (int i=0; i<table.getNumColumns(); i++){                    if (table.isColumnSelected(i))                        for (int j=0; j<table.getNumRows(); j++) {                            valid = valid && checkCell(cData, i, j, power);                        }                }                // then transform only if all selected cells are valid                if (valid) {                    undoInstructions = data.getUndoInstructionsAllData();                    for (int i=0; i<table.getNumColumns(); i++){                        if (table.isColumnSelected(i))                            for (int j=0; j<table.getNumRows(); j++) {                                transformCell(cData, i, j, power);                                did=true;                            }                    }                }            }            else {                // first check                for (int i=0; i<cData.getNumChars(); i++){                    for (int j=0; j<cData.getNumTaxa(); j++) {                        valid = valid && checkCell(cData, i, j, power);                        did=true;                    }                }                // then transform only if all selected cells are valid                if (valid) {                    undoInstructions = data.getUndoInstructionsAllData();                    for (int i=0; i<cData.getNumChars(); i++){                        for (int j=0; j<cData.getNumTaxa(); j++) {                            transformCell(cData, i, j, power);                            did=true;                        }                    }                }            }        }        if (undoInstructions!=null) {        	undoInstructions.setNewData(data);        	if (undoReference!=null){        		undoReference.setUndoer(undoInstructions);        		undoReference.setResponsibleModule(this);        	}        }        if (!valid){            alert("Values were not exponentially transformed because some values were either nonpositive or too large.");        }	        return did;    }    private boolean checkCell(ContinuousData data, int ic, int it, double power){        int item = 0; //TODO: other items        final double state = data.getState(ic,it, item);        if (MesquiteDouble.isCombinable(state))             if ((state<0) || (power*Math.log(state) > maxExp))                return false;            else                return true;        else             return true;   //if not combinable, transformCell ignores it, so should checkCell    }    private void transformCell(ContinuousData data, int ic, int it, double power){        int item = 0; //TODO: other items        final double state = data.getState(ic,it, item);        if (MesquiteDouble.isCombinable(state)) {            data.setState(ic,it, item,  Math.exp(power*Math.log(state)));         }    }    /*.................................................................................................................*/    public String getName() {        return "Raise to Power";    }    /*.................................................................................................................*/    public String getVersion() {        return "1.15";    }    /*.................................................................................................................*/    public boolean isPrerelease() {        return false;    }    /*................................................................................................................*/    public boolean isSubstantive(){        return true;    }            /*.................................................................................................................*/    public String getAuthors() {        return "Peter E. Midford, Ted Garland Jr., and Wayne P. Maddison";    }    /*.................................................................................................................*/    /** returns an explanation of what the module does.*/    public String getExplanation() {        return "Alters continuous data by raising values to a power." ;    }}