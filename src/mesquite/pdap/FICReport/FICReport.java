/* PDAP:PDTREE package for Mesquite  copyright 2001-2009 P. Midford & W. MaddisonPDAP:PDTREE is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.The web site for PDAP:PDTREE is http://mesquiteproject.org/pdap_mesquite/This source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.pdap.FICReport;/*~~  */import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.cont.lib.*;import mesquite.pdap.lib.*;/* ============  a file dumper for .FIC files created by PDTREE (Garland et al. 1993) ============*/// FIC files contain the following columns://     1.  Name of Contrast as Node - Node (e.g., 'Tm - Ta');//     2.  Name of Node at Base of Contrast//     3.  Unstandardized Contrast for Trait 1//     4.  Unstandardized Contrast for Trait 2//     5.  Standard Deviation of Contrast//             = square root of sum of corrected branch lengths//     6.  Nodal Value for Trait 1//     7.  Nodal Value for Trait 2//     8.  Uncorrected Height of Base Node from Root of Tree//     9.  Corrected Height of Base Node from Root of Tree//		(as used in screens 5, 6, 7, 8, and 11)//    10.  Average Uncorrected Height of Daughter Nodes//    11.  Average Corrected Height of Daughter Nodes//    12.  Name of First Daughter Branch (Descendant-Ancestor)//    13.  Corrected Length of First Daughter Branch//    14.  Name of Second Daughter Branch (Descendant-Ancestor)//    15.  Corrected Length of Second Daughter Branch/** */public class FICReport extends PDAPFileReporter {    public void getEmployeeNeeds(){  //This gets called on startup to harvest information; override this and inside, call registerEmployeeNeed        EmployeeNeed e = registerEmployeeNeed(ContrastForChar.class, getName() + "  needs a method to calculate contrasts.",        "The method to calculate contrasts is selected initially");    }            final static private String PDAPUNDEFINED = "-99999          ";  //PDAP style undefined value with padding    ContrastForChar contrastsTask;    BivariateContrastCalculator bCalc;    UnivariateContrastCalculator uCalc1;    UnivariateContrastCalculator uCalc2;    StatPakSource statPakTask;    private double[] xArray;    private double [] yArray;    private double [] xRawContrastArray;    private double [] yRawContrastArray;    private double [] sdArray;    private double [] vPrimeArray;    private double [] heightArray;    private double [] rawHeightArray;    private final String processedSuffixes = "#-+*:.=!";    public boolean useUnivariate = false;  //use univariate contrast calculators?    private int nameSize;    private String fillString = null;    /*.................................................................................................................*/    public boolean startJob(String arguments, Object condition, boolean hiredByName) {        if (contrastsTask == null)            contrastsTask =  (ContrastForChar)hireNamedEmployee(ContrastForChar.class, "#FelsContrWithChar");        if (contrastsTask == null) {            alert(getName() + " couldn't set up the FIC report generator because no calculator of Felsenstein's contrasts obtained.");            return false;        }        //xArray = new NumberArray(3);        //yArray = new NumberArray(3);        //xRawContrastArray = new NumberArray(3);        //yRawContrastArray = new NumberArray(3);        //SDArray = new NumberArray(3);        //VPrimeArray = new NumberArray(3);        //heightArray = new NumberArray(3);        //rawHeightArray = new NumberArray(3);        return true;  //false if no calculating employees could be found    }    public void employeeQuit(MesquiteModule m){        if (m==contrastsTask)            iQuit();    }    /*.................................................................................................................*/    /** Always true, because an FIC file always has tables. */    public boolean hasTables() {        return true;    }    /*.................................................................................................................*/    /** ask for formatting options */    public boolean getReportOptions(boolean dataSelected, boolean taxaSelected){        MesquiteInteger buttonPressed = new MesquiteInteger(1);        FICDialog reportDialog = new FICDialog(this,containerOfModule(), "FIC Report Options", buttonPressed);        reportDialog.addDefaultPanels(dataSelected, taxaSelected,useUnivariate);        boolean ok = (reportDialog.query(dataSelected,taxaSelected)==0);        reportDialog.dispose();        return ok;    }    /*.................................................................................................................*/    /**     * This procedure tries to get a name, either by generating it from the integer specifying the node or     * from the node's label.  In the latter case,if it appears to be processed, the name is unprocessed.     */    private String getName(Tree tree, int node) {        String name;        if (tree.getNodeLabel(node) == null)  { // No name, so we'll generate one from the node number            name = "Node" + Integer.toString(node);        }        else {            name = tree.getNodeLabel(node);            final int len = name.length();            if (((len == 2) && (processedSuffixes.indexOf(name.charAt(1)) != -1)) ||   //guessing name is processed                    ((len == 3) && (processedSuffixes.indexOf(name.charAt(2)) != -1))) {                name = name.substring(0,len-1);            }        }        return name;    }    /*.................................................................................................................*/    /**     * This finds the longest node label on the tree     */     private int checkNameLengths(Tree tree,int node) {        int size = getName(tree,node).length();        if (tree.nodeIsInternal(node)) {             for (int daughter = tree.firstDaughterOfNode(node); tree.nodeExists(daughter); daughter = tree.nextSisterOfNode(daughter)) {                int daughterLength = checkNameLengths(tree,daughter);                if (size < daughterLength)                    size = daughterLength;            }        }        return size;    }        private String makeFill(int len){        StringBuffer result = new StringBuffer(len);        for (int i=0;i<len;i++)            result.append(' ');        return result.toString();    }        /*.................................................................................................................*/    // This generates a fill string consisting of spaces equal to the difference between the length of name and the value len    private String addFill(String name, int len) {        if (name.length() == len)  //is this name construct equal to the maximum length?            return "";  // no fill needed        else             return fillString.substring(0,len);    }    /*...............................................................*/    //This should export the 15 columns in the .FIC file.  Like PDI, this assumes all nodes are fully resolved and    //have exactly two daugthers.  Unlike PDI, there is no obvious best way to extend to more than two characters -    //the raw contrasts are currently listed in columns 3&4, so would additional characters go on the end (16,17,etc)    //inserted after 5 and 6.  Since these files are intended to go into SPSS and similar programs, extra columns     //anywhere might break things.    private void reportNode(Tree tree, StringBuffer outputBuffer, int node, String lineEnding, String tableDelimiter) {        if (tree.nodeIsInternal(node)) { // only internal nodes have contrasts            String myName;            String firstDName;            String secondDName;            final int FirstDaughter = tree.firstDaughterOfNode(node);            final int SecondDaughter = tree.lastDaughterOfNode(node);            if (convertSpaces){                myName = spaceConvertString(getName(tree,node));                firstDName = spaceConvertString(getName(tree,FirstDaughter));                secondDName = spaceConvertString(getName(tree,SecondDaughter));            }            else {                myName = getName(tree,node);                firstDName = getName(tree,FirstDaughter);                secondDName = getName(tree,SecondDaughter);            }            //     1.  Name of Contrast as Node - Node            final String daughtersString = firstDName + "-" + secondDName;             outputBuffer.append(daughtersString + addFill(daughtersString,2*nameSize+1) +  tableDelimiter);            //     2.  Name of Node at Base of Contrast            outputBuffer.append(myName + addFill(myName,nameSize) + tableDelimiter);            //     3.  Unstandardized Contrast for Trait 1            appendFixedWidth(outputBuffer,xRawContrastArray[node],tableDelimiter);            //     4.  Unstandardized Contrast for Trait 2            appendFixedWidth(outputBuffer,yRawContrastArray[node],tableDelimiter);            //     5.  Standard Deviation of Contrast            //             = square root of sum of corrected branch lengths            appendFixedWidth(outputBuffer,sdArray[node],tableDelimiter);            //     6.  Nodal Value for Trait 1            appendFixedWidth(outputBuffer,xArray[node],tableDelimiter);            //     7.  Nodal Value for Trait 2            appendFixedWidth(outputBuffer,yArray[node],tableDelimiter);            //     8.  Uncorrected Height of Base Node from Root of Tree            appendFixedWidth(outputBuffer,rawHeightArray[node],tableDelimiter);            //     9.  Corrected Height of Base Node from Root of Tree            //		(as used in screens 5, 6, 7, 8, and 11)            appendFixedWidth(outputBuffer,heightArray[node],tableDelimiter);            //    10.  Average Uncorrected Height of Daughter Nodes            appendAverage(outputBuffer,rawHeightArray[FirstDaughter],rawHeightArray[SecondDaughter],tableDelimiter);            //    11.  Average Corrected Height of Daughter Nodes             appendAverage(outputBuffer,heightArray[FirstDaughter],heightArray[SecondDaughter],tableDelimiter);            //    12.  Name of First Daughter Branch (Descendant-Ancestor)            final String ancestorDaughter1String = firstDName + "-" + myName;            outputBuffer.append(ancestorDaughter1String + addFill(ancestorDaughter1String,2*nameSize+1) + tableDelimiter);            //    13.  Corrected Length of First Daughter Branch            appendFixedWidth(outputBuffer,vPrimeArray[FirstDaughter],tableDelimiter);            //    14.  Name of Second Daughter Branch (Descendant-Ancestor)            final String ancestorDaughter2String = secondDName + "-" + myName;            outputBuffer.append(ancestorDaughter2String + addFill(ancestorDaughter2String,2*nameSize+1) + tableDelimiter);            //    15.  Corrected Length of Second Daughter Branch            appendFixedWidth(outputBuffer,vPrimeArray[SecondDaughter],tableDelimiter);            outputBuffer.append(lineEnding);        }        for (int daughter = tree.firstDaughterOfNode(node); tree.nodeExists(daughter); daughter = tree.nextSisterOfNode(daughter))            reportNode(tree, outputBuffer, daughter,lineEnding,tableDelimiter);    }        private void appendFixedWidth(StringBuffer outputBuffer,double value,String tableDelimiter){        if (MesquiteDouble.isCombinable(value))            outputBuffer.append(MesquiteDouble.toFixedWidthString(value,15,false) + tableDelimiter);        else            appendUndefined(outputBuffer,tableDelimiter);                }    private void appendAverage(StringBuffer outputBuffer, double value1, double value2, String tableDelimiter){        if (MesquiteDouble.isCombinable(value1) && MesquiteDouble.isCombinable(value2)) {            outputBuffer.append(MesquiteDouble.toFixedWidthString((value1 + value2)/2,15,false) + tableDelimiter);        }        else appendUndefined(outputBuffer, tableDelimiter);    }        private void appendUndefined(StringBuffer outputBuffer, String tableDelimiter){        outputBuffer.append(PDAPUNDEFINED + tableDelimiter);    }    /*.................................................................................................................*/    /**     * This writes the FIC report string to a file.     */    public void writeReport(MesquiteFile file,CharacterDistribution data1,CharacterDistribution data2,Tree theTree, String arguments) { //todo: this should be passed scripting        final String output = reportToString(data1,data2,theTree);        if (output != null) {            String name = getProject().getHomeFileName();            if (name==null)                name = "untitled.fic";            else                 name = stripNex(name) + ".fic";            saveReportFile(output,arguments,name);        }    }    /**     * @return String contains the report     * No line or column delimiter specified, puts up a window instead.     */    public String reportToString(CharacterDistribution data1,CharacterDistribution data2,Tree theTree) { //todo: this should be passed scripting        if (!getReportOptions(false,false))            return "";        final String result = reportToString(data1,data2,theTree,getLineEnding(),getTableDelimiter(),useUnivariate);        if (result != null)            return result;        else            return "";    }    /*.................................................................................................................*/        /**     * @return String contains the report     * Version to keep PDAPFileReporter happy; defaults useUnivariateContrasts to false     */    public String reportToString(CharacterDistribution data1, CharacterDistribution data2, Tree theTree, String lineDelimiter, String columnDelimiter){        return reportToString(data1, data2,theTree,lineDelimiter,columnDelimiter,false);    }    /*.................................................................................................................*/    // This actually writes the report.    private String reportToString(CharacterDistribution data1,CharacterDistribution data2,Tree theTree,String lineDelimiter, String columnDelimiter, boolean useUnivariateContrasts) { //todo: this should be passed scripting        if ((!(data1 instanceof ContinuousDistribution))  || !(data2 instanceof ContinuousDistribution)) {            fireEmployee(contrastsTask);            contrastsTask = null;		            return null;        }        ContinuousDistribution states1 = (ContinuousDistribution)data1;        ContinuousDistribution states2 = (ContinuousDistribution)data2;        if (data1.getTaxa().getNumTaxa() != data2.getTaxa().getNumTaxa()) { // differing taxa sets (can we just compare the Taxa objects?) very bad            fireEmployee(contrastsTask);            contrastsTask = null;            return null;        }        if (useUnivariateContrasts){            if (uCalc1 == null)                uCalc1 = new UnivariateContrastCalculator(theTree,states1);            else                 uCalc1.reinitialize(theTree, null, states1);            if (uCalc2 == null)                uCalc2 = new UnivariateContrastCalculator(theTree,states2);            else                uCalc2.reinitialize(theTree,null,states2);        }        else {            if (bCalc == null)                bCalc = new BivariateContrastCalculator(theTree,states1,states2);            else                bCalc.reinitialize(theTree, null, states1, states2);        }        Taxa taxa = data1.getTaxa();        int numTaxa = taxa.getNumTaxa();        // Here we check whether this tree follows the rules for pdi files: internal nodes have names, all names are <= 2 chars or processed, ??bifurcating with ZLB's for polytomies...        nameSize = checkNameLengths(theTree,theTree.getRoot());        fillString = makeFill(2*nameSize+1);  //longest identifier we might encounter (two tips of nameSize joined by '-')        StringBuffer outputBuffer = new StringBuffer(256*(numTaxa+3) + 500);        if (contrastsTask == null) {            alert(getName() + " FIC report generator exiting because the calculator of Felsenstein's contrasts is gone.");            iQuit();        }        if (useUnivariateContrasts){            xRawContrastArray = uCalc1.rawContrastCalculation();            yRawContrastArray = uCalc2.rawContrastCalculation();            sdArray = uCalc1.stdDevCalculation();            xArray = uCalc1.getNodeValues();            yArray = uCalc2.getNodeValues();            rawHeightArray = uCalc1.heightCalculation(ContrastForChar.RAWHEIGHT);            heightArray = uCalc1.heightCalculation(ContrastForChar.CORRECTEDHEIGHT);            vPrimeArray = uCalc1.vPrimeCalculation();        }        else {  //use bivariate contrasts            xRawContrastArray = bCalc.rawContrastCalculation();            yRawContrastArray = bCalc.getRawContrasts2();            sdArray = bCalc.stdDevCalculation();            xArray = bCalc.getNodeValues();            yArray = bCalc.getNodeValues2();            rawHeightArray = bCalc.heightCalculation(ContrastForChar.RAWHEIGHT);            heightArray = bCalc.heightCalculation(ContrastForChar.CORRECTEDHEIGHT);            vPrimeArray = bCalc.vPrimeCalculation();        }        reportNode(theTree,outputBuffer,theTree.getRoot(),lineDelimiter,columnDelimiter);        outputBuffer.append("\n");        return outputBuffer.toString();    }    /*.................................................................................................................*/    public String getName() {        return "FIC (PDAP see Garland et. al. 1993)";    }    /*.................................................................................................................*/    public String getAuthors() {        return "Peter Midford, Theodore Garland Jr. & Wayne Maddison";    }    /*.................................................................................................................*/    public String getVersion() {        return "1.15";    }    /*.................................................................................................................*/    public boolean isPrerelease() {        return false;    }    /*.................................................................................................................*/    public boolean isSubstantive(){        return false;    }   	     /*.................................................................................................................*/    /** returns an explanation of what the module does.*/    public String getExplanation() {        return "Generates FIC format report files as described in Garland et al. 1993" ;    }    /*.................................................................................................................*/    /** returns current parameters, for logging etc..*/    public String getParameters() {        return "" ;    }}