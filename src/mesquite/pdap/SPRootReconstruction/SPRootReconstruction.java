/* PDAP:PDTREE package for Mesquite  copyright 2001-2009 P. Midford & W. MaddisonPDAP:PDTREE is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.The web site for PDAP:PDTREE is http://mesquiteproject.org/pdap_mesquite/This source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */// This class handles the calculations of root confidence and prediction intervals and the confidence// and prediction intervals around the regression line run through the root projected back into the// tip data plot (screens 9A and 9B).package mesquite.pdap.SPRootReconstruction;import JSci.maths.statistics.TDistribution;import mesquite.lib.MesquiteChart;import mesquite.lib.MesquiteDouble;import mesquite.lib.MesquiteInteger;import mesquite.lib.MesquiteNumber;import mesquite.lib.NumberArray;import mesquite.pdap.lib.BivariateContrastCalculator;import mesquite.pdap.lib.PDAPRootReconStatPak;import mesquite.pdap.lib.PDAPStatPak;import mesquite.pdap.lib.StatPakSource;/** */public class SPRootReconstruction extends StatPakSource  {	public boolean startJob(String arguments, Object condition, boolean hiredByName) {		return true;	}	public PDAPStatPak getStatPak(){		return new ReconStatPak();	}		public String getName(){		return "Source of statPaks for root reconstruction";	}		    /*.................................................................................................................*/    public String getAuthors() {        return "Peter E. Midford, Ted Garland Jr., and Wayne P. Maddison" ;    }    /*.................................................................................................................*/	/** returns module version */    public String getVersion() {        return "1.12";    }	/*.................................................................................................................*/  	 public boolean isPrerelease() {		return false;   	}	/*.................................................................................................................*/   	public boolean isSubstantive() {   		return false;    }        /*.................................................................................................................*/	public String getExplanation() {		return "Calculates root reconstruction summary statistics and values for a crosshairs over a scatterplot.";	}}class ReconStatPak extends PDAPRootReconStatPak {        /* The following are a set of accessors for slots that will be filled after a call to doCalculations - shouldn't be any reason to set them directly */        /** returns the confidence interval around the reconstructed root value */    public double getRootCI(int which) {        if (which >= 0 && which < 2)            return ci[which];        return MesquiteDouble.unassigned;    }           /** returns the standard error of the reconstructed root value */    public double getRootSE(int which) {        if (which >= 0 && which < 2)            return se[which];        return MesquiteDouble.unassigned;    }        /** Note: in order to get this method to work with these arguments, the RootStatPak needs to have    had tree and obs1 & obs2 previously set.  After this runs, all the values will be in place for a    root reconstruction plot or a CI/PI plot, though if Vh is not set, the Vh=0 default makes the CI    and PI widths identical.     @return boolean: true if the chart needs to remunch.*/        public boolean doCalculations(NumberArray xArray, NumberArray yArray, MesquiteChart chart){        final BivariateContrastCalculator calculator = new BivariateContrastCalculator(tree, obs1, obs2);        //boolean xOk = false;        boolean result = false;        min[0] = MesquiteDouble.infinite;        min[1] = MesquiteDouble.infinite;        max[0] = MesquiteDouble.negInfinite;        max[1] = MesquiteDouble.negInfinite;                contrasts1 = calculator.contrastCalculation();        contrasts2 = calculator.getContrasts2();        x1 = calculator.getNodeValues();        x2 = calculator.getNodeValues2();        vPrime1 = calculator.getVPrime();        countContrasts(tree);        tStats = new TDistribution(getNumberMinus1()-getDFReduction());        double conSlope = contrastSlope(tree,contrasts1,contrasts2,tree.getRoot());        calcReconstructions(tree,x1,x2,contrasts1,contrasts2,vPrime1,conSlope);        // finally, set some minimum and maximum limits for the confidence interval plot (8-20-02 PEM)        // calculate some maximum and minimum y values, so PI lines and the ends of the cross hairs fit on the display        double minX = mean[0]-ci[0];        if (minX > min[0])            minX = min[0];        double maxX = mean[0]+ci[0];        if (maxX < max[0])            maxX = max[0];        double minY = mean[1]-ci[1];        if (minY > min[1])            minY = min[1];        double maxY = mean[1]+ci[1];        if (maxY < max[1])            maxY = max[1];        double middlex = (maxX+minX)/2.0;        double middley = (maxY+minY)/2.0;        minX = minX-(middlex-minX)*CIPLOTOVERAGE;        maxX = maxX+(maxX-middlex)*CIPLOTOVERAGE;        minY = minY-(middley-minY)*CIPLOTOVERAGE;        maxY = maxY+(maxY-middley)*CIPLOTOVERAGE;        result = setRootChartLimits(minX,maxX,minY,maxY,chart);        return result;    }        /*.................................................................................................................*/    private boolean setRootChartLimits(double minX, double maxX, double minY, double maxY, MesquiteChart chart) {        boolean needsRedraw = false;        if (chart != null){    //otherwise nothing to work with...            if (chart.getMinimumX()==null || outsideLowTolerance(chart.getMinimumX(),minX)) {  //no constraint value, so just set it                chart.constrainMinimumX(new MesquiteNumber(minX));                needsRedraw = true;            }            if (chart.getMaximumX()==null || outsideHighTolerance(chart.getMaximumX(),maxX)) {  //no constraint, so just set it                chart.constrainMaximumX(new MesquiteNumber(maxX));                needsRedraw = true;            }            if (chart.getMinimumY()==null || outsideLowTolerance(chart.getMinimumY(),minY)) {  //no constraint, so just set it                chart.constrainMinimumY(new MesquiteNumber(minY));                needsRedraw = true;            }            if (chart.getMaximumY()==null || outsideHighTolerance(chart.getMaximumY(),maxY)) {  //no constraint, so just set it                chart.constrainMaximumY(new MesquiteNumber(maxY));                needsRedraw = true;            }        }        return needsRedraw;          }    /*-----------------------------------------*/    /** This method returns a string describing the contents of the statPak.  This string is    displayed at the bottom of the text pane of the diagnostic screen. */    public String flst() {        if (!MesquiteDouble.isCombinable(ls))            return "";        final double width100 = width1*100;        StringBuffer results = new StringBuffer(400);        results.append("Number of tips:  " + (getNumber()+1) + "\n");        results.append("Number of independent contrasts:  " + getNumber() + "\n");        results.append("Number of counted polytomies:  " + polytomies + "\n");        results.append("User-specified degrees of freedom reduction for computing C.I.'s:  " + getDFReduction() + "\n\n");        results.append("Slope (least squares):              " + ls + "\n");        results.append("Standard Error:                     " + slopeSE + "\n");        results.append(" Lower " + width100 + "% Confidence Interval:   " + (ls-slopeCI) + "\n");        results.append(" Upper " + width100 + "% Confidence Interval:   " + (ls+slopeCI) + "\n");        results.append("Intercept (least squares):         " + lsy + "\n");        results.append(" Standard Error:                    " + interSE + "   / as mapped back onto \\ \n");        results.append(" Lower " + width100 + "% Confidence Interval:  " + (lsy-interCI) + "  |  the original data    | \n");        results.append(" Upper " + width100 + "% Confidence Interval:  " + (lsy+interCI) + "   \\ space               /  \n\n");        results.append("                                            X = Trait " + (n1+1));        results.append("       Y = Trait " + (n2+1) + "\n");        results.append("Estimated Root Node Values:              " + mean[n1] + "  " + mean[n2] + "\n");        results.append("Rates of Evolution:                      " + variance[n1] + " " + variance[n2] + "\n");        results.append("Standard Errors of Root Node Estimates:  " + se[n1] + " " + se[n2] + "\n");        results.append("Lower " + width100 + "% Confidence Intervals:        " + (mean[n1]-ci[n1]));        results.append(" " + (mean[n2]-ci[n2]) + "\n");        results.append("Upper " + width100 + "% Confidence Intervals:        " + (mean[n1]+ci[n1]));        results.append(" " + (mean[n2]+ci[n2]) + "\n\n");        return results.toString();    }       /**     * Support for Mesquite 2.5+ 'step through trees'     */    public MesquiteNumber[] getWritableResults(){        if (writableResults == null){            writableResults = new MesquiteNumber[22];            writableResults[0] = new MesquiteNumber();            writableResults[0].setName("Number of tips");            writableResults[1] = new MesquiteNumber();            writableResults[1].setName("Number of independent contrasts");            writableResults[2] = new MesquiteNumber();            writableResults[2].setName("Number of counted polytomies");            writableResults[3] = new MesquiteNumber();            writableResults[3].setName("User-specified degrees of freedom reduction for computing C.I.'s");            writableResults[4] = new MesquiteNumber();            writableResults[4].setName("Slope (least squares)");            writableResults[5] = new MesquiteNumber();            writableResults[5].setName("Standard Error");            writableResults[6] = new MesquiteNumber();            writableResults[7] = new MesquiteNumber();            writableResults[8] = new MesquiteNumber();            writableResults[8].setName("Intercept (least squares)" );            writableResults[9] = new MesquiteNumber();            writableResults[9].setName(" Standard Error");            writableResults[10] = new MesquiteNumber();            writableResults[11] = new MesquiteNumber();            writableResults[12] = new MesquiteNumber();            writableResults[12].setName("Estimated Root Node Values (X)");            writableResults[13] = new MesquiteNumber();            writableResults[13].setName("Estimated Root Node Values (Y)");            writableResults[14] = new MesquiteNumber();            writableResults[14].setName("Rates of Evolution");            writableResults[15] = new MesquiteNumber();            writableResults[15].setName("Rates of Evolution");            writableResults[16] = new MesquiteNumber();            writableResults[16].setName("Standard Errors of Root Node Estimates");            writableResults[17] = new MesquiteNumber();            writableResults[17].setName("Standard Errors of Root Node Estimates");            writableResults[18] = new MesquiteNumber();            writableResults[19] = new MesquiteNumber();            writableResults[20] = new MesquiteNumber();            writableResults[21] = new MesquiteNumber();        }        String wStr = "95";                if (!MesquiteDouble.isCombinable(ls)){            wStr = MesquiteInteger.toString((int)(getWidth1()*100));        }        writableResults[6].setName("Lower " + wStr + "% Confidence Interval (X)");        writableResults[7].setName("Upper " + wStr + "% Confidence Interval (X)");        writableResults[10].setName("Lower " + wStr + "% Confidence Interval (Y)");        writableResults[11].setName("Upper " + wStr + "% Confidence Interval (Y)");        writableResults[18].setName("Lower " + wStr + "% Confidence Intervals (X)");        writableResults[19].setName("Upper " + wStr + "% Confidence Intervals (X)");        writableResults[20].setName("Lower " + wStr + "% Confidence Intervals (Y)");        writableResults[21].setName("Upper " + wStr + "% Confidence Interval (Y)");                    writableResults[0].setValue(getNumber()+1);        writableResults[1].setValue(getNumber());        writableResults[2].setValue(polytomies);        writableResults[3].setValue(getDFReduction());        writableResults[4].setValue(ls);        writableResults[5].setValue(getSlopeSE());        writableResults[6].setValue(ls+getSlopeCI());        writableResults[7].setValue(ls-getSlopeCI());        writableResults[8].setValue(getLeastSquaresYIntercept());        writableResults[9].setValue(getInterceptSE());        writableResults[10].setValue(getLeastSquaresYIntercept()+getInterceptCI());        writableResults[11].setValue(getLeastSquaresYIntercept()+getInterceptCI());        writableResults[12].setValue(mean[0]);        writableResults[13].setValue(mean[1]);        writableResults[14].setValue(getVariance(0));        writableResults[15].setValue(getVariance(1));        writableResults[16].setValue(se[0]);        writableResults[17].setValue(se[1]);        writableResults[18].setValue(mean[0]-ci[0]);        writableResults[19].setValue(mean[0]+ci[0]);        writableResults[20].setValue(mean[1]-ci[1]);        writableResults[21].setValue(mean[1]+ci[1]);        return writableResults;    }    public String CIString(String lineEnding, String tableDelimiter, boolean convertSpaces) {        return "";    }    }