/* PDAP:PDTREE package for Mesquite  copyright 2001-2009 P. Midford & W. MaddisonPDAP:PDTREE is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.The web site for PDAP:PDTREE is http://mesquiteproject.org/pdap_mesquite/This source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.pdap.ScatterRootRegCIPI;/*~~  */import java.awt.*;import java.util.*;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.pdap.RootedRegression.RootedRegression;import mesquite.pdap.lib.*;public class ScatterRootRegCIPI extends ScatterRegisterableAsst  {        public void getEmployeeNeeds(){  //This gets called on startup to harvest information; override this and inside, call registerEmployeeNeed        EmployeeNeed e = registerEmployeeNeed(RootRegressionCalculator.class, getName() + "  needs a method to calculate root regressions.",        "The method to calculate root regressions is selected initially");    }                private ArrayList extras;    RootRegressionCalculator rootStatTask;    PDAPTreeWinAsstC chartModule;        public boolean startJob(String arguments, Object condition, boolean hiredByName) {        extras = new ArrayList();        rootStatTask = (RootRegressionCalculator)hireNamedEmployee(RootedRegression.class, "#RootedRegression");        if (rootStatTask == null)            return sorry(getName() + " couldn't start because no calculating module for root regression obtained.");        return true;    }    /**     * @return false - no obvious way to extract the CI file contents for multiple trees.     */    public boolean suppliesWritableResults(){        return false;    }    public Object getResultsHeading() {        return getName();    }        /**     * @return computed values with descriptive strings     */    public MesquiteNumber[] getWritableResults() {        return null;    }    /*.................................................................................................................*/    public String getLegendText(){        return "";    }    /*.................................................................................................................*/    public boolean getUserChooseable(){        return false;    }    /*.................................................................................................................*/    public boolean canHireMoreThanOnce () {        return false;    }    /*.................................................................................................................*/    public void setChartModule(PDAPTreeWinAsstC module){        chartModule = module;        rootStatTask.setChartModule(module);    }    /*.................................................................................................................*/    public ChartExtra createExtra(MesquiteChart chart){        rootStatTask.setChart(chart);        ChartExtra s = new SRDExtra(this, chart);        extras.add(s);        return s;    }    /*.................................................................................................................*/    public String getName(){        return "Tip Scattergram with Root Regression Confidence and Prediction Intervals";    }    /*.................................................................................................................*/    public String getAuthors() {        return "Peter E. Midford, Ted Garland Jr., and Wayne P. Maddison" ;    }    /*.................................................................................................................*/    /** returns module version */    public String getVersion() {        return "1.12";    }    /*.................................................................................................................*/    public boolean isPrerelease() {        return false;    }    /** This makes sure all the extras are turned off if the job is ending */    public void endJob(){        if (extras != null) {            for (int i=0; i<extras.size(); i++){                if (extras.get(i) != null){                    ChartExtra extra = (ChartExtra)extras.get(i);                    extra.turnOff();                }                else                    MesquiteMessage.warnProgrammer("Found a null entry in the list of chartExtras of the ScatterRootRegCIPI while ending");            }        }        super.endJob();    }}class SRDExtra extends ChartExtra {    CharacterDistribution cd1;    CharacterDistribution cd2;    Tree tree;    public SRDExtra(MesquiteModule ownerModule, MesquiteChart chart){        super(ownerModule, chart);    }    /* Peter: Note this is a different convention from that I'm suggesting for the other Scatter Diagnostics.  Your convention is related */    /* Wayne: finally, after 5 years, I think this is closer and avoids the infinite recursion problem */	/**Do any calculations needed*/    private NumberArray calculationsResult = new NumberArray(1);    private MesquiteString calculationsResultString = new MesquiteString();    public boolean doCalculations(){         // here you can put the main calculations.         if (((ScatterRootRegCIPI)ownerModule).chartModule == null)            return false;        cd1 = ((ScatterRootRegCIPI)ownerModule).chartModule.getObserved1();        cd2 = ((ScatterRootRegCIPI)ownerModule).chartModule.getObserved2();        tree = ((ScatterRootRegCIPI)ownerModule).chartModule.getTree();        // Here the root diagnostics module should be consulted to calculate what is needed        //NumberArray result = new NumberArray(1);        //MesquiteString resultString = new MesquiteString("");        calculationsResult.setToUnassigned(0);        calculationsResultString.setValue("");        //Need to store results so as to be called later for drawing & writing        ((ScatterRootRegCIPI)ownerModule).rootStatTask.calculateNumbers(tree,cd1,cd2,calculationsResult,calculationsResultString);        if ("Needs remunching".equals(calculationsResultString.getValue())){            calculationsResultString.setValue("CI and PI around Regression through root");            return true;        }        else            return false;    }    /**draw on the chart*/    // This tells the statpak to draw the OLS regression line and curves representing the confidence and prediation intervals.    public void drawOnChart(Graphics g){        PDAPRootRegStatPak rootStats = (PDAPRootRegStatPak)((ScatterRootRegCIPI)ownerModule).rootStatTask.getStatPak();        if (rootStats == null)            return;        final double ls = rootStats.getLeastSquaresSlope();        if (!MesquiteDouble.isCombinable(ls) || !MesquiteDouble.isCombinable(rootStats.getVh()))            return;        final Charter c = chart.getCharter();        if (c == null)            return;        NumberArray Xpoints = chart.getXArray().cloneArray();        final double min0 = rootStats.getMin(0);        final double max0 = rootStats.getMax(0);        final double lsy = rootStats.getLeastSquaresYIntercept();        final double width1 = rootStats.getWidth1();        final double width2 = rootStats.getWidth2();                final int startX = c.xToPixel(min0,chart);             final int startYOLS =  c.yToPixel(ls*min0+lsy,chart);        final int endX = c.xToPixel(max0,chart);        final int endYOLS = c.yToPixel(ls*max0+lsy,chart);        final int extraLineWidth = 1;                int oldX = MesquiteInteger.unassigned;        int oldYLow = MesquiteInteger.unassigned;        int oldYHigh = MesquiteInteger.unassigned;                g.setColor(Color.red);        oldX = MesquiteInteger.unassigned;        Xpoints.sortUp();        for (int i=0;i<chart.getNumPoints();i++) {            // plot Confidence Interval line (segments) for width1            double curX = Xpoints.getDouble(i);            if (curX != MesquiteDouble.unassigned) {                double yHat = ls*curX+lsy;                double yCWidth = rootStats.calcCI(curX,0,width1);                //if the CI isn't calculable, set the width to zero and the main line will overwrite                if (!MesquiteDouble.isCombinable(yCWidth))                    yCWidth = 0;                int plotX = c.xToPixel(curX,chart);                int plotHigh = c.yToPixel((yHat + yCWidth),chart);                int plotLow = c.yToPixel((yHat - yCWidth),chart);                showLineSegment(g,oldX,oldYHigh,plotX,plotHigh,oldYLow, plotLow);                oldX = plotX;                oldYLow = plotLow;                oldYHigh = plotHigh;            }               }        g.setColor(Color.green);        oldX = MesquiteInteger.unassigned;        for (int i=0;i<chart.getNumPoints();i++) {            // plot Prediction Interval line (segments) for width1            double curX = Xpoints.getDouble(i);            if (curX != MesquiteDouble.unassigned) {                double yHat = ls*curX+lsy;                double yPWidth = rootStats.calcPI(curX,0,width1);                //if the PI isn't calculable, set the width to zero and the main line will overwrite                if (!MesquiteDouble.isCombinable(yPWidth))                    yPWidth = 0;                int plotX = c.xToPixel(curX,chart);                int plotHigh = c.yToPixel((yHat + yPWidth),chart);                int plotLow = c.yToPixel((yHat - yPWidth),chart);                showLineSegment(g,oldX,oldYHigh,plotX,plotHigh,oldYLow, plotLow);                oldX = plotX;                oldYLow = plotLow;                oldYHigh = plotHigh;            }               }                g.setColor(Color.orange);        oldX = MesquiteInteger.unassigned;        Xpoints.sortUp();        for (int i=0;i<chart.getNumPoints();i++) {            // plot Confidence Interval line (segments) for width2            double curX = Xpoints.getDouble(i);            if (curX != MesquiteDouble.unassigned) {                double yHat = ls*curX+lsy;                double yCWidth = rootStats.calcCI(curX,0,width2);                //if the CI isn't calculable, set the width to zero and the main line will overwrite                if (!MesquiteDouble.isCombinable(yCWidth))                    yCWidth = 0;                int plotX = c.xToPixel(curX,chart);                int plotHigh = c.yToPixel((yHat+yCWidth),chart);                int plotLow = c.yToPixel((yHat-yCWidth),chart);                showLineSegment(g,oldX,oldYHigh,plotX,plotHigh,oldYLow, plotLow);                oldX = plotX;                oldYLow = plotLow;                oldYHigh = plotHigh;            }               }        g.setColor(Color.cyan);        oldX = MesquiteInteger.unassigned;        for (int i=0;i<chart.getNumPoints();i++) {            // plot Prediction Interval line (segments) for width2            double curX = Xpoints.getDouble(i);            if (curX != MesquiteDouble.unassigned) {                double yHat = ls*curX+lsy;                double yPWidth = rootStats.calcPI(curX,0,width2);                //if the PI isn't calculable, set the width to zero and the main line will overwrite                if (!MesquiteDouble.isCombinable(yPWidth))                    yPWidth = 0;                int plotX = c.xToPixel(curX,chart);                int plotHigh = c.yToPixel((yHat + yPWidth),chart);                int plotLow = c.yToPixel((yHat - yPWidth),chart);                showLineSegment(g,oldX,oldYHigh,plotX,plotHigh,oldYLow, plotLow);                oldX = plotX;                oldYLow = plotLow;                oldYHigh = plotHigh;            }               }                g.setColor(Color.black);        // plot the main regression line and thicken it        g.drawLine(startX, startYOLS,endX,endYOLS);        if (Math.abs(endYOLS-startYOLS)>(endX-startX))   // abs(slope) > 1            g.drawLine(startX+extraLineWidth,startYOLS,endX+extraLineWidth,endYOLS);        else g.drawLine(startX,startYOLS+extraLineWidth,endX,endYOLS+extraLineWidth);                    //Plot the -10..10 points and any user defined points         double incr = (max0-min0)/100.0;        for(int i = -10; i <= -1; i++){            double x = min0 + incr*i;            double yHat = ls*x + lsy;            showPoint(x,yHat,rootStats,chart,g);        }         for(int i = 1; i <= 10; i++){            double x = max0+incr*i;            double yHat = ls*x + lsy;            showPoint(x,yHat,rootStats,chart,g);        }         for (int i=0; i < rootStats.getCIPIValuesSize(); i++){            double x = rootStats.CIPIValueAt(i).getValue();            double yHat = ls*x + lsy;            showPoint(x,yHat,rootStats,chart,g);        }    }  /* end of drawRegressionCiPiOnChart() */        /** Result of refactoring */    private void showLineSegment(Graphics g, int oldX, int oldYHigh, int plotX, int plotHigh, int oldYLow, int plotLow) {        if (MesquiteInteger.isCombinable(oldX)) {            g.drawLine(oldX,oldYHigh,plotX,plotHigh);            g.drawLine(oldX,oldYLow,plotX,plotLow);        }    }        /** Draw CI/PI line segments (despite method name) for values that don't correspond to tips */    private void showPoint(double x, double yHat, PDAPRootRegStatPak rootStats, MesquiteChart chart, Graphics g) {        final double width1 = rootStats.getWidth1();        final double width2 = rootStats.getWidth2();        Charter c = chart.getCharter();        double yCWidth = rootStats.calcCI(x,0,width1);        final int plotX = c.xToPixel(x,chart);        final int plotLeft = plotX-1;        final int plotYHat = c.yToPixel(yHat,chart);        double highY = yHat + yCWidth;        double lowY = yHat - yCWidth;        int plotHigh = c.yToPixel(highY,chart);        int plotLow = c.yToPixel(lowY,chart);        g.setColor(Color.darkGray);        g.drawLine(plotLeft,plotYHat,plotX,plotYHat);        g.setColor(Color.red);        g.drawLine(plotLeft,plotHigh,plotX,plotHigh);        g.drawLine(plotLeft,plotLow,plotX,plotLow);        double yPWidth = rootStats.calcPI(x,0,width1);        highY = yHat + yPWidth;        lowY = yHat - yPWidth;        plotHigh = c.yToPixel(highY,chart);        plotLow = c.yToPixel(lowY,chart);        g.setColor(Color.green);        g.drawLine(plotLeft,plotHigh,plotX,plotHigh);        g.drawLine(plotLeft,plotLow,plotX,plotLow);        yCWidth = rootStats.calcCI(x,0,width2);        highY = yHat + yCWidth;        lowY = yHat - yCWidth;        plotHigh = c.yToPixel(highY,chart);        plotLow = c.yToPixel(lowY,chart);        g.setColor(Color.orange);        g.drawLine(plotLeft,plotHigh,plotX,plotHigh);        g.drawLine(plotLeft,plotLow,plotX,plotLow);        yPWidth = rootStats.calcPI(x,0,width2);        highY = yHat + yPWidth;        lowY = yHat - yPWidth;        plotHigh = c.yToPixel(highY,chart);        plotLow = c.yToPixel(lowY,chart);        g.setColor(Color.cyan);        g.drawLine(plotLeft,plotHigh,plotX,plotHigh);        g.drawLine(plotLeft,plotLow,plotX,plotLow);     }                 /**print on the chart*/    public void printOnChart(Graphics g){        drawOnChart(g);    }    public String writeOnChart(){        PDAP2CTStatPak rootStats = ((ScatterRootRegCIPI)ownerModule).rootStatTask.getStatPak();        if (rootStats != null)            return rootStats.flst();        else            return "";    }    /**to inform ChartExtra that cursor has just entered point*/    public void cursorEnterPoint(int point, int exactPoint, Graphics g){        //Debugg.println("enter point " + point);    }    /**to inform ChartExtra that cursor has just exited point*/    public void cursorExitPoint(int point, int exactPoint, Graphics g){        //Debugg.println("exit point " + point);    }    /**to inform ChartExtra that cursor has just touched point*/    public void cursorTouchPoint(int point, int exactPoint, Graphics g){        //Debugg.println("touch point " + point);    }}