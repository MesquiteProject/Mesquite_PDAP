/* PDAP:PDTREE package for Mesquite  copyright 2001-2009 P. Midford & W. MaddisonPDAP:PDTREE is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.The web site for PDAP:PDTREE is http://mesquiteproject.org/pdap_mesquite/This source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.pdap.RootedRegression;/*~~  */import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.lib.tree.MesquiteTree;import mesquite.lib.tree.Tree;import mesquite.lib.tree.TreeReference;import mesquite.lib.ui.AlertDialog;import mesquite.lib.ui.MesquiteChart;import mesquite.cont.lib.*;import mesquite.pdap.CIReport.CIReport;import mesquite.pdap.SPRootRegression.SPRootRegression;import mesquite.pdap.lib.*;/* ======================================================================== */public class RootedRegression extends RootRegressionCalculator {    public void getEmployeeNeeds(){  //This gets called on startup to harvest information; override this and inside, call registerEmployeeNeed        EmployeeNeed e = registerEmployeeNeed(SPRootRegression.class, getName() + "  needs a method to calculate correlations.",        "The method to calculate correlations is selected initially");        EmployeeNeed e2 = registerEmployeeNeed(CIReport.class, getName() + "  needs a method to generate CI reports.",        "The method to generate CI reports is selected initially");    }        Tree myTree = null;    TreeReference lastTreeReference;    String DiagnosticString;    PDAPRootRegStatPak myStats = null;    StatPakSource sp2cts;    MesquiteChart chart;    PDAPTreeWinAsstC chartModule = null;    CIReport CIReportTask;    ContinuousDistribution observedStates1 = null;    ContinuousDistribution observedStates2 = null;    /*.................................................................................................................*/    public boolean startJob(String arguments, Object condition, boolean hiredByName) {        lastTreeReference = null;        addMenuItem("Root Calculation Query Mode...", makeCommand("setVerboseQueryMode",  (Commandable)this));        addMenuItem("Set CI/PI width...", makeCommand("setwidth",  (Commandable)this));         addMenuItem("Set Vh...", makeCommand("setvh",  (Commandable)this));         addMenuItem("Set Polytomy DF Reduction...", makeCommand("setDFReduction",  (Commandable)this));         addMenuItem("Ignore Root Tritomies...", makeCommand("setIgnoreRootTritomies", (Commandable)this));        addMenuItem("Show CI/PI columns (text window)",makeCommand("showCIPIColumns", (Commandable)this));        addMenuItem("Add a value to the CI/PI table",makeCommand("addCIPIvalues",(Commandable)this));        addMenuItem(null, "Write CI/PI table to a file", makeCommand("writeCI", (Commandable)this));        sp2cts = (StatPakSource)hireNamedEmployee(SPRootRegression.class, "#SPRootRegression");        if (sp2cts == null)            return sorry(getName() + " couldn't start because no calculator of correlation obtained");        //myStats = sp2cts.getStatPak();	        CIReportTask = (CIReport)hireNamedEmployee(CIReport.class, "#CIReport");        if (CIReportTask == null)            return sorry(getName() + " couldn't start because no CI reporter module obtained."); 		        return true;    }    /*-----------------------------------------*/     public Snapshot getSnapshot(MesquiteFile file) {        if (myStats == null)            return null;        if (myStats.getCIPIValuesSize()==0)            return null;        final Snapshot temp = new Snapshot();        for(int i=0;i<myStats.getCIPIValuesSize();i++)            temp.addLine("addCIPIvalues " + myStats.CIPIValueAt(i).toString());        return temp;    }    /*-----------------------------------------*/    /**     *  This just generates the description of the columns in the CI/PI file.  It's     *  broken out to make doCommand easier to follow.     *  @return String the columns' description     */    private String makeCIPIcolumnString() {        double width1 = 0.95;        double width2 = 0.90;        if (myStats != null) {            width1 = myStats.getWidth1();            width2 = myStats.getWidth2();        }        final String width1percent = MesquiteDouble.toString(width1*100);        final String width2percent = MesquiteDouble.toString(width2*100);        return("The Confidence and Prediction interval (CI/PI) value dump on the text pane contains the following columns:\n\n" +                " 1.  Tip Name\n" +                " 2.  X Value\n" +                " 3.  Observed Y Value (or -99999 for generated X values)\n" +                " 4.  Predicted Y Value (Yhat)\n" +                " 5.  Lower " + width1percent + "% Confidence Interval\n" +                 " 6.  Upper " + width1percent + "% Confidence Interval\n" +                " 7.  Lower " + width1percent + "% Prediction Interval\n" +                " 8.  Upper " + width1percent + "% Prediction Interval\n" +                " 9.  Lower " + width2percent + "% Confidence Interval\n" +                "10.  Upper " + width2percent + "% Confidence Interval\n" +                "11.  Lower " + width2percent + "% Prediction Interval\n" +                "12.  Upper " + width2percent + "% Prediction Interval\n");    }    /** 	 *  The dispatcher for mesquite/script commands     */    public Object doCommand(String commandName, String arguments, CommandChecker checker) {        if (myStats == null)            return null;        final Class thisClass = this.getClass();        if (checker.compare(thisClass,"Sets the first width for the confidence and prediction intervals","[a confidence width e.g., 0.95]",commandName,"setwidth1")){            double newWidth= MesquiteDouble.fromString(arguments, new MesquiteInteger(0));            if (!MesquiteDouble.isCombinable(newWidth)){                chartModule.queryWidths();                newWidth = chartModule.getWidth1();            }            myStats.setWidth1(newWidth);            chartModule.setWidthQueryDone(true);            parametersChanged();        }        else if (checker.compare(thisClass,"Sets the second width for the confidence and prediction intervals","[a confidence width e.g., 0.90]",commandName,"setwidth2")){            MesquiteInteger pos = new MesquiteInteger(0);            double newWidth= MesquiteDouble.fromString(arguments, pos);            if (!MesquiteDouble.isCombinable(newWidth)){                chartModule.queryWidths();                newWidth = chartModule.getWidth2();            }            myStats.setWidth2(newWidth);            chartModule.setWidthQueryDone(true);            parametersChanged();        }        else if (checker.compare(thisClass,"Sets both widths for the confidence and prediction intervals","[two confidence widths e.g., 0.95 0.90]",commandName,"setwidth")){            MesquiteInteger pos = new MesquiteInteger(0);            double newWidth1= MesquiteDouble.fromString(arguments, pos);            MesquiteInteger pos2 = null;            double newWidth2 = MesquiteDouble.unassigned;			            if (MesquiteDouble.isCombinable(newWidth1)) {                pos2 = new MesquiteInteger(arguments.indexOf(' ',0));                if (pos2.getValue()>0)                    newWidth2 = MesquiteDouble.fromString(arguments,pos2);            }            if (!MesquiteDouble.isCombinable(newWidth1) ||                    !MesquiteDouble.isCombinable(newWidth2)){                chartModule.queryWidths();                newWidth1 = chartModule.getWidth1();                newWidth2 = chartModule.getWidth2();            }            myStats.setWidth1(newWidth1);            myStats.setWidth2(newWidth2);            chartModule.setWidthQueryDone(true);            parametersChanged();        }        else if (checker.compare(thisClass,"Sets the tip to root distance for added nodes in prediction interval regression estimates","[a real number]",commandName,"setvh")) {            MesquiteInteger pos = new MesquiteInteger(0);            double newVh= MesquiteDouble.fromString(arguments, pos);            if (!MesquiteDouble.isCombinable(newVh))                myStats.setVh(chartModule.queryVh(myStats));            else                 myStats.setVh(newVh);            parametersChanged();        }        else if (checker.compare(thisClass,"Sets the degrees of freedom reduced because of polytomies","[number of dof]",commandName,"setDFReduction")) {            MesquiteInteger pos = new MesquiteInteger(0);            int dfReduction= MesquiteInteger.fromFirstToken(arguments, pos);            if (!MesquiteInteger.isCombinable(dfReduction))                chartModule.queryDFReduce(myStats, true);            else                chartModule.setDFReduction(dfReduction);            chartModule.setDFQueryDone(true);            myStats.setDFReduction(chartModule.getDFReduction());            parametersChanged();        }        else if (checker.compare(thisClass, "Sets the query mode to verbose or not", "[on/off]", commandName, "setVerboseQueryMode")) {            if (StringUtil.blank(arguments))                 chartModule.queryVerboseQueryMode();            else                chartModule.toggleVerboseQueryMode(parser.getFirstToken(arguments));        }        else if (checker.compare(thisClass,"Sets whether to ignore a tritomy at the root ", "[boolean]",commandName, "setIgnoreRootTritomies")){            if (StringUtil.blank(arguments))                 chartModule.queryIgnoreRootTritomies();            else{                String s = parser.getFirstToken(arguments);                chartModule.setIgnoreRootTritomies("on".equalsIgnoreCase(s));            }             myStats.setIgnoreRootTritomies(chartModule.getIgnoreRootTritomies());        }        else if (checker.compare(thisClass,"Write CI/PI table to a file",null,commandName,"writeCI")) {            CIReportTask.setStatPak(myStats);            MesquiteFile CIfile = new MesquiteFile();            CIReportTask.writeReport(CIfile,observedStates1,observedStates2,myTree,arguments);	        }        else if (checker.compare(thisClass,"Show CI/PI columns (text window)","",commandName, "showCIPIColumns")){            String description = makeCIPIcolumnString();            AlertDialog.notice(null,"CI/PI Columns",description);        }        else if(checker.compare(thisClass,"Add a value to the CI/PI table","[a real number]",commandName,"addCIPIValues")) {            double newValue;            if (StringUtil.blank(arguments)){                newValue = MesquiteDouble.queryDouble(null,"Add CI/PI value","Enter x (horizontal trait) value to add to the CI/PI table",0.0);            }            else{                MesquiteInteger pos = new MesquiteInteger(0);                newValue = MesquiteDouble.fromString(arguments, pos);            }            if (MesquiteDouble.isCombinable(newValue))                myStats.addCIPIValue(new MesquiteDouble(newValue));        }   		        else            return  super.doCommand(commandName, arguments, checker);        return null;    }    /*-----------------------------------------*/    public void setChartModule(PDAPTreeWinAsstC module) {        chartModule = module;        myStats = (PDAPRootRegStatPak)sp2cts.getStatPak();        myStats.setDFReduction(chartModule.getDFReduction());        myStats.setIgnoreRootTritomies(chartModule.getIgnoreRootTritomies());    }    /*-----------------------------------------*/        public PDAPRootStatPak getStatPak() {        if (chartModule == null){            MesquiteMessage.warnProgrammer("No chartModule set for "+this);            return null;        }        if (myStats == null){            myStats = (PDAPRootRegStatPak)sp2cts.getStatPak();            myStats.setDFReduction(chartModule.getDFReduction());            myStats.setIgnoreRootTritomies(chartModule.getIgnoreRootTritomies());        }        return myStats;    }    public void setChart(MesquiteChart chart){        this.chart = chart;    }    /*.................................................................................................................*/    public void calculateNumbers(Tree tree, CharacterDistribution charDistribution1, CharacterDistribution charDistribution2,            NumberArray result,            MesquiteString resultString) {        if (result==null || tree == null)            return;        if (!(charDistribution1 instanceof ContinuousDistribution) ||!(charDistribution2 instanceof ContinuousDistribution))            return;        clearResultAndLastResult(result);        result.zeroArray();        observedStates1 = (ContinuousDistribution)charDistribution1;        observedStates2 = (ContinuousDistribution)charDistribution2;        if ((lastTreeReference == null) || (tree instanceof MesquiteTree && !((MesquiteTree)tree).sameTreeVersions(lastTreeReference, true, true))) { // Peter: tighter restrictions; any change will provoke query or reset            // first create and initialize the new rootStatPak            myStats = (PDAPRootRegStatPak)sp2cts.getStatPak();            myStats.setDFReduction(chartModule.getDFReduction());            myStats.setIgnoreRootTritomies(chartModule.getIgnoreRootTritomies());            // now set the tree so doCalculations will do the right thing...            myStats.setTree(tree);            final int root = tree.getRoot();            myStats.countInternalNodes(tree,root);  // count the internal nodes, to set number            int zlb = ((NoPolyTree)tree).countZLBs(myStats.getIgnoreRootTritomies());     // Zero-Length-Branches are what PDAP calls "polytomies"; count to inform the user            // now ask the user to set df Reductions            if (!MesquiteThread.isScripting()){                if (!chartModule.getDFQueryDone() &&                         ((zlb > 0) || chartModule.getVerboseQueryMode())){                    chartModule.queryDFReduce(myStats,true);                    myStats.setDFReduction(chartModule.getDFReduction());                    chartModule.setDFQueryDone(true);                }                if (chartModule.getVerboseQueryMode() && !chartModule.getVhQueryDone()){                    chartModule.queryVh(myStats);                    myStats.setVh(chartModule.getVh());                    chartModule.setVhQueryDone(true);                }                else{                    myStats.setVh(myStats.getMeanHeight(tree));                }                if (chartModule.getVerboseQueryMode() && !chartModule.getWidthQueryDone()){                    chartModule.queryWidths();                    myStats.setWidth1(chartModule.getWidth1());                    myStats.setWidth2(chartModule.getWidth2());                    chartModule.setWidthQueryDone(true);                }            }            else {                myStats.setDFReduction(chartModule.getDFReduction());                myStats.setIgnoreRootTritomies(chartModule.getIgnoreRootTritomies());                myStats.setWidth1(chartModule.getWidth1());                myStats.setWidth2(chartModule.getWidth2());                myStats.setVh(myStats.getMeanHeight(tree));            }        }        myTree = tree;        lastTreeReference = ((MesquiteTree)tree).getTreeReference(lastTreeReference);        if ((observedStates1 != null) || (observedStates2 != null)) {            NumberArray xArray = new NumberArray();             NumberArray yArray = new NumberArray();            myStats.setObserved1(observedStates1);            myStats.setObserved2(observedStates2);            boolean munch = myStats.doCalculations(xArray,yArray,chart);            // Results are never set - we just leave the tip data untouched for display            if (resultString == null)                MesquiteMessage.warnProgrammer("RootedRegression should NOT be called with an empty result string - uncontrolled recursion may occur");            else {                if (munch)                    resultString.setValue("Needs remunching");                else                    resultString.setValue("CI and PI around Regression through root");            }        }        saveLastResult(result);        saveLastResultString(resultString);    }    /*.................................................................................................................*/    /*.................................................................................................................*/    public Class getCharacterClass() {        return ContinuousState.class;    }    /*.................................................................................................................*/    public CompatibilityTest getCompatibilityTest() {        return new ContinuousStateTest();    }    /** returns current parameters, for logging etc..*/    /*.................................................................................................................*/    public String getParameters() {        return "Regression through reconstructed root";    }    /*.................................................................................................................*/    public String getName() {        return "Regression through Reconstructed Root Value";    }    /*.................................................................................................................*/    public String getAuthors() {        return "Peter E. Midford, Ted Garland Jr., and Wayne P. Maddison" ;    }    /*.................................................................................................................*/    public String getVersion() {        return "1.15";    }    /*.................................................................................................................*/    public boolean isPrerelease() {        return false;    }    /*................................................................................................................*/    public boolean isSubstantive(){        return true;    }            /*.................................................................................................................*/    public String getExplanation() {        return "Calculates regression passing through a reconstruction of characters at the root.";    }}