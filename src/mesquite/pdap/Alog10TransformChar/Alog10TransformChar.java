/* PDAP:PDTREE package for Mesquite  copyright 2001-2010 P. Midford & W. MaddisonPDAP:PDTREE is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.The web site for PDAP:PDTREE is http://mesquiteproject.org/pdap_mesquite/This source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)*/package mesquite.pdap.Alog10TransformChar;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.cont.lib.*;import mesquite.lib.table.*;/** ======================================================================== */public class Alog10TransformChar extends ContDataAlterer {	static final double log10 = Math.log(10.0);	static final double maxExp = Math.log(Double.MAX_VALUE)/log10;	/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, boolean hiredByName) {		return true;	}			/** Called to alter data in those cells selected in table*/	public boolean alterData(CharacterData data, MesquiteTable table, UndoReference undoReference){	    boolean valid=true;	    boolean did=false;	    if (!(data instanceof ContinuousData))	        return false;	    UndoInstructions undoInstructions = null;	    ContinuousData cData = (ContinuousData)data;	    if (table==null && data !=null){	        // first check	        for (int i=0; i<cData.getNumChars(); i++){	            for (int j=0; j<cData.getNumTaxa(); j++) {	                valid = valid && checkCell(cData, i, j);	            }	        }	        // then transform only if all cells are valid	        if (valid) {	            undoInstructions = data.getUndoInstructionsAllData();	            for (int i=0; i<cData.getNumChars(); i++){	                for (int j=0; j<cData.getNumTaxa(); j++) {	                    transformCell(cData, i, j);	                    did=true;	                }	            }	        }	    }	    else if (table!=null && cData !=null){	        if (table.anyCellSelected()) {	            // first check	            for (int i=0; i<table.getNumColumns(); i++)	                for (int j=0; j<table.getNumRows(); j++)	                    if (table.isCellSelected(i,j)) {	                        valid = valid && checkCell(cData, i, j);	                    }	            // then transform only if all selected cells are valid	            if (valid) {	                undoInstructions = data.getUndoInstructionsAllData();	                for (int i=0; i<table.getNumColumns(); i++)	                    for (int j=0; j<table.getNumRows(); j++)	                        if (table.isCellSelected(i,j)) {	                            transformCell(cData, i, j);	                            did = true;	                        }	            }	        }	        else if (table.anyRowSelected()) {	            // first check	            for (int j=0; j<table.getNumRows(); j++) {	                if (table.isRowSelected(j))	                    for (int i=0; i<table.getNumColumns(); i++) {	                        valid = valid && checkCell(cData, i, j);	                    }	            }	            // then transform only if all selected cells are valid	            if (valid) {	                undoInstructions = data.getUndoInstructionsAllData();	                for (int j=0; j<table.getNumRows(); j++) {	                    if (table.isRowSelected(j))	                        for (int i=0; i<table.getNumColumns(); i++) {	                            transformCell(cData, i, j);	                            did = true;	                        }	                }	            }	        }	        else if (table.anyColumnSelected()) {	            // first check	            for (int i=0; i<table.getNumColumns(); i++){	                if (table.isColumnSelected(i))	                    for (int j=0; j<table.getNumRows(); j++) {	                        valid = valid && checkCell(cData, i, j);	                    }	            }	            // then transform only if all selected cells are valid	            if (valid) {	                undoInstructions = data.getUndoInstructionsAllData();	                for (int i=0; i<table.getNumColumns(); i++){	                    if (table.isColumnSelected(i))	                        for (int j=0; j<table.getNumRows(); j++) {	                            transformCell(cData, i, j);	                            did=true;	                        }	                }	            }	        }	        else {	            // first check	            for (int i=0; i<cData.getNumChars(); i++){	                for (int j=0; j<cData.getNumTaxa(); j++) {	                    valid = valid && checkCell(cData, i, j);	                    did=true;	                }	            }	            // then transform only if all selected cells are valid	            if (valid) {	                undoInstructions = data.getUndoInstructionsAllData();	                for (int i=0; i<cData.getNumChars(); i++){	                    for (int j=0; j<cData.getNumTaxa(); j++) {	                        transformCell(cData, i, j);	                        did=true;	                    }	                }	            }	        }	    }	    if (undoInstructions!=null) {	        undoInstructions.setNewData(data);	        if (undoReference!=null){	            undoReference.setUndoer(undoInstructions);	            undoReference.setResponsibleModule(this);	        }	    }	    if (!valid){	        alert("Values were not alog 10 transformed because some values were too large.");	    }		    return did;	}	private boolean checkCell(ContinuousData data, int ic, int it){		int item = 0; //TODO: other items				double state = data.getState(ic,it, item);		if (MesquiteDouble.isCombinable(state)) 			return (state<=maxExp);		else			return true;  //if not combinable, transformCell ignores it, so should checkCell 	}   		private void transformCell(ContinuousData data, int ic, int it){		int item = 0; //TODO: other items				double state = data.getState(ic,it, item);		if (MesquiteDouble.isCombinable(state)) {			data.setState(ic,it, item, Math.exp(state*log10));		}	}		/*.................................................................................................................*/	/** returns a descriptive name for the module 	    @return String */    public String getName() {		return "Alog 10 transform";   	}	/*.................................................................................................................*/	/** returns a descriptive name for the module 	    @return String */  	public String getVersion() {		return "1.15";   	}	/*.................................................................................................................*/	/** marks the module as NOT being a prerelease 	    @return boolean - constant false */	public boolean isPrerelease() {		return false;	}   			/** marks the module as doing a substantive calculation - not decorative */	public boolean isSubstantive(){        return true;	}	/*.................................................................................................................*/ 	/** returns an explanation of what the module does. 	    @return String */ 	public String getExplanation() { 		return "Alters continuous data by antilog base 10 transforming values." ;   	}   	 }