/* PDAP:PDTREE package for Mesquite  copyright 2001-2009 P. Midford & W. MaddisonPDAP:PDTREE is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.The web site for PDAP:PDTREE is http://mesquiteproject.org/pdap_mesquite/This source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html)*/package mesquite.pdap.ExpTransform;/*~~  */import mesquite.lib.*;import mesquite.lib.duties.*;/** ======================================================================== */public class ExpTransform extends BranchLengthsAlterer {    static final double maxExp = Math.log(Double.MAX_VALUE);    double resultNum;    /*.................................................................................................................*/    public boolean startJob(String arguments, Object condition, boolean hiredByName) {		        return true;    }    /*.................................................................................................................*/    /**     * @param tree     * @param resultString passed in, never filled        * @return returns true because this assumes the calling code is always responsible for notifying listeners of tree     *     * Real entry point for the transform - a wrapper around the recursive method doTransform     *     */    public boolean transformTree(AdjustableTree tree, MesquiteString resultString){        // hoisting the start of the up-pass here removes the need to handle node==root case in doTransform        for (int daughter=tree.firstDaughterOfNode(tree.getRoot()); tree.nodeExists(daughter); daughter = tree.nextSisterOfNode(daughter) ) {            doTransform(tree, daughter);        }        return true;    }    /**     *      * @param tree phylogeny to transform     * @param node whose branch to ancestor this will transform     * If node is not root and the ancestor length is combineable, replace that lenght with its exp     */    private void doTransform(AdjustableTree tree, int node) {        final double currentLength = tree.getBranchLength(node);        if (MesquiteDouble.isCombinable(currentLength)){            if(currentLength <= maxExp)                tree.setBranchLength(node,Math.exp(currentLength), false);            else                tree.setBranchLength(node,MesquiteDouble.infinite,false);        }        for (int daughter=tree.firstDaughterOfNode(node); tree.nodeExists(daughter); daughter = tree.nextSisterOfNode(daughter) ) {            doTransform(tree, daughter);        }    }    /*.................................................................................................................*/    public String getName() {        return "Exponential Transform of Branch Lengths";    }    /*.................................................................................................................*/    public String getVersion() {        return "1.15";    }    /*.................................................................................................................*/    public boolean isPrerelease() {        return false;    }    /** marks the module as doing a substantive calculation - not decorative */    public boolean isSubstantive(){        return true;    }    /*.................................................................................................................*/    public String getAuthors() {        return "Peter E. Midford, Ted Garland Jr., and Wayne P. Maddison";    }    /*.................................................................................................................*/    /** returns an explanation of what the module does.*/    public String getExplanation() {        return "Adjusts a tree's branch lengths to the exponential transform of its length." ;    }}