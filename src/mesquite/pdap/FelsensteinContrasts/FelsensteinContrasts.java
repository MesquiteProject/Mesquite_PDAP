/* PDAP:PDTREE package for Mesquite  copyright 2001-2009 P. Midford & W. MaddisonPDAP:PDTREE is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.The web site for PDAP:PDTREE is http://mesquiteproject.org/pdap_mesquite/This source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.pdap.FelsensteinContrasts;/*~~  */import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.lib.duties.*;import mesquite.cont.lib.*;import mesquite.pdap.lib.*;/** ======================================================================== */public class FelsensteinContrasts extends ContrastCoordinator implements Incrementable {    public void getEmployeeNeeds(){  //This gets called on startup to harvest information; override this and inside, call registerEmployeeNeed        EmployeeNeed e = registerEmployeeNeed(CharacterOneSource.class, getName() + "  needs a method to provide characters.",        "The method to supply characters is selected initially");        EmployeeNeed e1 = registerEmployeeNeed(ContrastForChar.class, getName() + "  needs a method to calculate contrasts.",        "The method to calculate contrasts is selected initially");    }    ContinuousDistribution observedStates;    CharacterOneSource characterSourceTask;    ContrastForChar contrastsTask;    NumberArray numbers;    Taxa currentTaxa;    Tree tree;    int currentChar=0;    int currentItem=0;    long oldTreeVersion = 0;    long oldTreeID = 0;    boolean characterSet = false;    int lastCharRetrieved = -1;    MesquiteString charSourceName;    MesquiteMenuItemSpec itemItem;    MesquiteCommand itemChoiceCommand, cstC;    String itemName=null;    /*.................................................................................................................*/    public boolean startJob(String arguments, Object condition, boolean hiredByName) {        characterSourceTask = (CharacterOneSource)hireCompatibleEmployee(CharacterOneSource.class, ContinuousState.class, "Source of characters (for Felsenstein's constrasts)");        if (characterSourceTask == null) {            return sorry(getName() + " couldn't start because no source of characters obtained");        }        charSourceName = new MesquiteString(characterSourceTask.getName());        contrastsTask = (ContrastForChar)hireEmployee(ContrastForChar.class, "Calculator for character contrasts on tree");        if (contrastsTask == null) {            return sorry(getName() + " couldn't start because no contrast calculator obtained");        }        if (getHiredAs() != ContrastCoordinator.class) {            contrastsTask.takeControl(true);            addMenuItem( "Next Character", makeCommand("nextCharacter",  (Commandable)this));            addMenuItem( "Previous Character", makeCommand("previousCharacter",  (Commandable)this));            addMenuItem( "Choose Character", makeCommand("chooseCharacter",  (Commandable)this));        }        cstC =  makeCommand("setCharacterSource",  (Commandable)this);        characterSourceTask.setHiringCommand(cstC);        if (numModulesAvailable(CharacterOneSource.class)>1){ //, ContinuousState.class              MesquiteSubmenuSpec mss = addSubmenu(null, "Character source",cstC, CharacterOneSource.class);            mss.setSelected(charSourceName);        }        /*		addMenuItem( "Next Character", makeCommand("nextCharacter",  (Commandable)this));		addMenuItem( "Previous Character", makeCommand("previousCharacter",  (Commandable)this));		addMenuItem( "Choose Character", makeCommand("chooseCharacter",  (Commandable)this));         */        itemChoiceCommand = MesquiteModule.makeCommand("setItem",  (Commandable)this);        return true;      }    public void employeeQuit(MesquiteModule m){        if (m!=characterSourceTask)            iQuit();    }    /*.................................................................................................................*/    /** returns current parameters, for logging etc..*/    public String getParameters() {        if (itemName!=null)            return contrastsTask.getParameters() + " of " + characterSourceTask.getNameAndParameters() + " (item " + itemName + ")";        else            return contrastsTask.getParameters() + " of " + characterSourceTask.getNameAndParameters(); 			    }    /*.................................................................................................................*/    public void setCurrent(long i){        if (characterSourceTask==null || currentTaxa==null){            currentChar = (int)i;            characterSet=true;        }        else if ((i>=0) && (i<=characterSourceTask.getNumberOfCharacters(currentTaxa)-1)) {            currentChar = (int)i;            characterSet=true;            //parametersChanged(false);        }    }    public String getItemTypeName(){        return "Character";    }    /*.................................................................................................................*/    public long toInternal(long i){        return(CharacterStates.toInternal((int)i));    }    /*.................................................................................................................*/    public long toExternal(long i){        return(CharacterStates.toExternal((int)i));    }    /*.................................................................................................................*/    public long getCurrent(){        return currentChar;    }    /*.................................................................................................................*/    public long getMin(){        return 0;    }    /*.................................................................................................................*/    public long getMax(){        if (characterSourceTask==null || currentTaxa==null)            return 0;        return characterSourceTask.getNumberOfCharacters(currentTaxa)-1;    }    public void setOption(int option){        if (contrastsTask!=null)            contrastsTask.setOption(option);    }    /*.................................................................................................................*/    public Snapshot getSnapshot(MesquiteFile file) {        //TODO: allow change in assignTask, etc.        Snapshot temp = new Snapshot();        temp.addLine( "getCharacterSource " , characterSourceTask);        temp.addLine("setCharacter " + CharacterStates.toExternal(currentChar));        temp.addLine("setItem " + (currentItem));        return temp;    }    /*.................................................................................................................*/    public Object doCommand(String commandName, String arguments, CommandChecker checker) {        if (checker.compare(this.getClass(), "Sets module supplying characters", "[name of module]", commandName, "setCharacterSource")) {//temporary            return characterSourceTask.doCommand(commandName, arguments, checker);        }        else if (checker.compare(this.getClass(), "Returns module supplying characters", null, commandName, "getCharacterSource")) {            return characterSourceTask;        }        else if (checker.compare(this.getClass(), "Goes to next character", null, commandName, "nextCharacter")) {            if (currentChar>=characterSourceTask.getNumberOfCharacters(currentTaxa)-1)                currentChar=0;            else                currentChar++;            parametersChanged();        }        else if (checker.compare(this.getClass(), "Goes to previous character", null, commandName, "previousCharacter")) {            if (currentChar<=0)                currentChar=characterSourceTask.getNumberOfCharacters(currentTaxa)-1;            else                currentChar--;            parametersChanged();        }        else if (checker.compare(this.getClass(), "Queries character as to charcter to use", null, commandName, "chooseCharacter")) {            int ic=characterSourceTask.queryUserChoose(currentTaxa, " for Felsenstein's contrasts " + whatIsMyPurpose());            if (MesquiteInteger.isCombinable(ic)) {                currentChar = ic;                characterSet=true;                parametersChanged(); //?            }        }        else if (checker.compare(this.getClass(), "Sets the character to use", "[number of character]", commandName, "setCharacter")) {            int ic = CharacterStates.toInternal(MesquiteInteger.fromString(arguments));            if (currentTaxa==null) {                currentChar = ic;                characterSet=true;            }            if ((ic>=0) && (ic<=characterSourceTask.getNumberOfCharacters(currentTaxa)-1)) {                currentChar = ic;                characterSet=true;                parametersChanged();            }        }        else if (checker.compare(this.getClass(), "Sets which item (from a multi-item continuous matrix) is used", "[number of item]", commandName, "setItem")) {            int ic = MesquiteInteger.fromString(arguments);            if (!MesquiteInteger.isCombinable(ic) && observedStates!=null){                int numItems =observedStates.getNumItems();                String[] items = new String[numItems];                for (int i=0; i<items.length; i++){                    if (StringUtil.blank(observedStates.getItemName(i)))                        items[i] = "(unnamed)";                    else                        items[i]= observedStates.getItemName(i);                }                ic = ListDialog.queryList(containerOfModule(), "Item for contrasts", "Calculate contrasts for item:", MesquiteString.helpString, items, 0);            }            if (!MesquiteInteger.isCombinable(ic))                return null;            if (currentTaxa==null) {                currentItem = ic;            }            else if (observedStates !=null && observedStates instanceof ContinuousDistribution) {                if ((ic>=0) && (ic<=observedStates.getNumItems()-1)) {                    currentItem = ic;                    parametersChanged();                }            }        }        else             return super.doCommand(commandName, arguments, checker);        return null;    }    /*.................................................................................................................*/    public void employeeParametersChanged(MesquiteModule employee, MesquiteModule source, Notification notification) {        observedStates = null;//to force recalculation        super.employeeParametersChanged(module, source, notification);    }    /** Called to provoke any necessary initialization.  This helps prevent the module's intialization queries to the user from   	happening at inopportune times (e.g., while a long chart calculation is in mid-progress)*/    public void initialize(Tree tree){        currentTaxa = tree.getTaxa();        //((MesquiteNumber)null).toString();        characterSourceTask.initialize(currentTaxa);        int nums = characterSourceTask.getNumberOfCharacters(currentTaxa);        if (!MesquiteThread.isScripting() && nums>1 && MesquiteInteger.isCombinable(nums) && (!characterSet || currentChar>=nums)) {            int ic=characterSourceTask.queryUserChoose(currentTaxa, " for Felsenstein's contrasts " + whatIsMyPurpose());            if (MesquiteInteger.isCombinable(ic)) {                currentChar = ic;                characterSet=true;            }        }    }    /*.................................................................................................................*/    public  void calculateNumbers(Tree tree, NumberArray result, MesquiteString resultString) {        if (result==null)            return;        clearResultAndLastResult(result);        this.tree = tree;        itemName=null;        Taxa taxa = tree.getTaxa();        if (taxa != currentTaxa || (characterSourceTask.usesTree() && (tree.getID() != oldTreeID || tree.getVersionNumber() != oldTreeVersion)) || currentChar != lastCharRetrieved || observedStates == null ) {             int maxnum = characterSourceTask.getNumberOfCharacters(tree);            currentTaxa = taxa;            if (currentChar>= maxnum)                currentChar = maxnum-1;            observedStates = (ContinuousDistribution)characterSourceTask.getCharacter(tree, currentChar);            oldTreeVersion = tree.getVersionNumber();            oldTreeID = tree.getID();            lastCharRetrieved = currentChar;        }        if (resultString!=null)            resultString.setValue("");        if (observedStates != null) {            contrastsTask.calculateNumbers(tree, observedStates, result, resultString);        }        saveLastResult(result);        saveLastResultString(resultString);    }    /*.................................................................................................................*/    public String getName() {        return "PDAP contrasts";    }    /*.................................................................................................................*/    public String getVersion() {        return "1.15";    }    /*.................................................................................................................*/    public boolean isPrerelease() {        return false;    }    /** marks the module as doing a substantive calculation - not decorative */    public boolean isSubstantive(){        return true;    }    /*.................................................................................................................*/    /** returns an explanation of what the module does.*/    public String getExplanation() {        return "Coordinates the calculation of Felsenstein's contrasts and other statistics for continuous-valued characters on a tree.";    }}