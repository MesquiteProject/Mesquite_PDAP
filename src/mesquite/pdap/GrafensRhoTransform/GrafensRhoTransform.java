/* PDAP:PDTREE package for Mesquite  copyright 2001-2009 P. Midford & W. MaddisonPDAP:PDTREE is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.The web site for PDAP:PDTREE is http://mesquiteproject.org/pdap_mesquite/This source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.pdap.GrafensRhoTransform;/*~~  */import mesquite.lib.*;import mesquite.lib.duties.*;import mesquite.lib.tree.AdjustableTree;/** ======================================================================== */public class GrafensRhoTransform extends BranchLengthsAlterer {    double resultNum;    double rho;    /*.................................................................................................................*/    /**     * @param arguments     * @param condition     * @param hiredByName     *      * When hired, this module immediately asks for a value for Rho      */    public boolean startJob(String arguments, Object condition, boolean hiredByName) {        //TODO is this the right place to be doing this        if (!MesquiteThread.isScripting()) {            rho= MesquiteDouble.queryDouble(containerOfModule(),                     "Rho Value",                     "Choose a value for Grafen's Rho",                    0.5,                    0.0,                    MesquiteDouble.infinite);            if (rho == MesquiteDouble.unassigned) {                return false;            }	        }        return true;    }    /*.................................................................................................................*/    //Returns true if calling code is responsible for notifying listeners of tree     public  boolean transformTree(AdjustableTree tree, MesquiteString resultString, boolean notify){        doTransform(tree);        //Debugg.println notify       return true;    }    // This method transforms any set of branch lengths using the rho transform of Grafen (1989).      // It then checks the tree's height, and saves it.  It then scales the tree to a height of one.      // It changes the branch lengths to be a measure of the distance from the top of the tree to each node.    // Note that the branch length field is being used for something other than    // storing branch lengths.  It then raises each distance (stored in branch    // length) to the power rho.  Finally it changes the distances back to    // branch lengths and rescales the tree.  Note that if the original tree    // had contemporaneous tips, then the transformed tree will also.  For a    // discussion of transforming branch lengths in the context of Felsenstein's    // (1985) method of phylogenetically independent contrasts, see Garland    // et al. (1992, Systematic Biology 41:18-32.}    private void doTransform(AdjustableTree tree) {        MesquiteDouble height = new MesquiteDouble(0.0);        //MesquiteDouble checkHeight = new MesquiteDouble(0.0);  // debug variable        double multiplier;        int root = tree.getRoot();        heightCalculation(tree,0,height,root);        multiplier = 1/height.getValue();        scl(tree,root,multiplier);        //heightCalculation(tree,0,checkHeight,tree.getRoot());        //Debugg.println("After scl, height is: " + checkHeight.getValue());        //checkHeight.setValue(0.0);         t1(tree,root,0);        //heightCalculation(tree,0,checkHeight,tree.getRoot());        //Debugg.println("After t1, height is: " + checkHeight.getValue());         //checkHeight.setValue(0.0);         expMe(tree,root,rho);        //heightCalculation(tree,0,checkHeight,tree.getRoot());        //Debugg.println("After expMe, height is: " + checkHeight.getValue());         //checkHeight.setValue(0.0);         t2(tree,root);        //heightCalculation(tree,0,checkHeight,tree.getRoot());        //Debugg.println("After t2, height is: " + checkHeight.getValue());         //checkHeight.setValue(0.0);         scl(tree,root,height.getValue());        //heightCalculation(tree,0,checkHeight,tree.getRoot());        //Debugg.println("After scl, height is: " + checkHeight.getValue());         //checkHeight.setValue(0.0);     }    // This method just gets the height of the tree.  There may be somewhere else I could get this,    // but since I don't know where, I'll just copy some code from the diagnostic screens.    // This is a little different from DOS PDAP, where calculating the height comes as part of    // the tree drawing code.    private void heightCalculation(AdjustableTree tree, double ht, MesquiteDouble max, int node) {        if (node != tree.getRoot())            ht = ht + tree.getBranchLength(node);        else            ht = 0;        if (tree.nodeIsInternal(node)) {             for (int daughter = tree.firstDaughterOfNode(node); tree.nodeExists(daughter); daughter = tree.nextSisterOfNode(daughter))                heightCalculation(tree, ht, max, daughter);        }        else            if (ht > max.getValue())                max.setValue(ht);    }    // This is another helper method.  It is given the scaling factor, and then traverses the tree, multiplying all the branch    // lengths by the correct amount.    private void scl(AdjustableTree tree, int nd, double mult) {        if (nd != tree.getRoot()) {            tree.setBranchLength(nd,mult*tree.getBranchLength(nd),false);        }        if (tree.nodeIsInternal(nd))            for (int daughter = tree.firstDaughterOfNode(nd); tree.nodeExists(daughter); daughter = tree.nextSisterOfNode(daughter))                scl(tree, daughter, mult);    }    // This method traverses the tree and raises all the branch lengths to a power.    private void expMe(AdjustableTree tree, int nd, double power) {        if  ((tree.getRoot() != nd) &&                 (tree.getBranchLength(nd) > 0.0) &&                (MesquiteDouble.isCombinable(tree.getBranchLength(nd))))            tree.setBranchLength(nd, Math.exp(power*Math.log(tree.getBranchLength(nd))),false);        else                                                   if (tree.getRoot() != nd && (MesquiteDouble.isCombinable(tree.getBranchLength(nd))))                tree.setBranchLength(nd,0,false);        if (tree.nodeIsInternal(nd))            for (int daughter = tree.firstDaughterOfNode(nd); tree.nodeExists(daughter); daughter = tree.nextSisterOfNode(daughter))                expMe(tree, daughter, power);    }    // This is the first of two support methods.  It transforms the tree so that the branch    // length field no longer holds the branch length, but holds the distance    // from the highest tip to itself.  Because the procedure assumes that    // the has already been transformed to a height of one, this distance is    // just 1 minus the height of the node.    private void  t1(AdjustableTree tree, int nd, double ht){        if (nd != tree.getRoot())             ht += tree.getBranchLength(nd);        if (tree.nodeIsInternal(nd)) {            for (int daughter=tree.firstDaughterOfNode(nd); tree.nodeExists(daughter); daughter = tree.nextSisterOfNode(daughter) )                 t1(tree, daughter,ht);        }        if (nd != tree.getRoot())            tree.setBranchLength(nd,1-ht,false);        if (tree.getBranchLength(nd)<1e-18) 	// length must be due to roundoff error so             tree.setBranchLength(nd,0,false);   	// zero it out; constant changed 12-27-99 PEM     }    // This is the second of two support methods.    // This recursive procedure transforms the tree so that the branch    // length field holds the branch length, assuming that it previously held    // the distance from the highest tip to the node below previously.    // It also assumes that the height of the tree is one to start with.    private void t2(AdjustableTree tree, int nd){        if (tree.nodeIsInternal(nd)) {            for (int daughter=tree.firstDaughterOfNode(nd); tree.nodeExists(daughter); daughter = tree.nextSisterOfNode(daughter) )                 t2(tree, daughter);        }        boolean rootFamily = false;        if (nd == tree.getRoot()) rootFamily = true;        for (int daughter=tree.firstDaughterOfNode(tree.getRoot()); tree.nodeExists(daughter); daughter = tree.nextSisterOfNode(daughter) )             if (daughter == nd)                 rootFamily = true;        if (!rootFamily)  {            tree.setBranchLength(nd,tree.getBranchLength(tree.motherOfNode(nd))-tree.getBranchLength(nd),false);        }	        else             if (nd != tree.getRoot())                 tree.setBranchLength(nd,1-tree.getBranchLength(nd),false);    }    /*.................................................................................................................*/    public String getName() {        return "Grafen's (1989) Rho transform";    }    /*.................................................................................................................*/    public String getVersion() {        return "1.15";    }    /*.................................................................................................................*/    public boolean isPrerelease() {        return false;    }    /*................................................................................................................*/    public boolean isSubstantive(){        return true;    }            /*.................................................................................................................*/    public String getAuthors() {        return "Peter E. Midford, Ted Garland Jr., and Wayne P. Maddison";    }    /*.................................................................................................................*/    /** returns an explanation of what the module does.*/    public String getExplanation() {        return "Adjusts a tree's branch lengths according Grafen's (1989) Rho transform" ;    }}