/* PDAP:PDTREE package for Mesquite  copyright 2001-2009 P. Midford & W. MaddisonPDAP:PDTREE is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.The web site for PDAP:PDTREE is http://mesquiteproject.org/pdap_mesquite/This source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.pdap.FelsensteinCorrelation;/*~~  */import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.cont.lib.*;import mesquite.lib.duties.*;import mesquite.lib.tree.MesquiteTree;import mesquite.lib.tree.Tree;import mesquite.lib.ui.ExtensibleDialog;import mesquite.lib.ui.MesquiteSubmenuSpec;import mesquite.lib.ui.RadioButtons;import mesquite.pdap.lib.*;/** ======================================================================== *///Peter: this is a new module (see also NumForTreeWith2Chars in Basic).public class FelsensteinCorrelation extends NumberFor2CharAndTree {    public void getEmployeeNeeds(){  //This gets called on startup to harvest information; override this and inside, call registerEmployeeNeed        EmployeeNeed e = registerEmployeeNeed(PDAP2CTStatPakSource.class, getName() + "  needs a method to provide PDAP2CT StatPaks.",        "The method to supply PDAP 2CT STATPAKs is selected initially");        EmployeeNeed e1 = registerEmployeeNeed(ContrastForChar.class, getName() + "  needs a method to calculate contrasts.",        "The method to calculate contrasts is selected initially");    }    ContrastForChar contrastsTask;    PDAP2CTStatPakSource statPakTask;    private NumberArray xArray, yArray;    boolean r2 = true; // 3 choices: r, r2, p-value    StringArray modes;    MesquiteString modeName;    static final int REPORT_r = 0;    static final int REPORT_r2 = 1;    static final int REPORT_p = 2;    int reportMode = REPORT_r;    /*.................................................................................................................*/    public boolean startJob(String arguments, Object condition, boolean hiredByName) {        contrastsTask = (ContrastForChar)hireNamedEmployee(ContrastForChar.class, "#FelsContrWithChar");        if (contrastsTask == null)            return sorry(getName() + " couldn't start because no calculator of Felsenstein's contrasts obtained.");        contrastsTask.setOption(ContrastForChar.CONTRAST);        statPakTask = (PDAP2CTStatPakSource)hireNamedEmployee(PDAP2CTStatPakSource.class, "#SPOriDiagnostics");        if (statPakTask == null)            return sorry(getName() + " couldn't start because no calculator of correlation obtained.");        xArray = new NumberArray(3);        yArray = new NumberArray(3);        modes = new StringArray(3);          modes.setValue(REPORT_r, "r");  //the strings passed will be the menu item labels        modes.setValue(REPORT_r2, "r-squared");        modes.setValue(REPORT_p, "P value");        modeName = new MesquiteString(modes.getValue(reportMode));  //this helps the menu keep track of checkmenuitems        MesquiteSubmenuSpec mss = addSubmenu(null, "Report Correlation As", makeCommand("setReportMode", this), modes);         mss.setSelected(modeName);        if (!MesquiteThread.isScripting())            showReportModeDialog();        return true; //false if no appropriate employees!    }    private void showReportModeDialog(){        MesquiteInteger buttonPressed = new MesquiteInteger(1);        ExtensibleDialog dialog = new ExtensibleDialog(containerOfModule(), "How to Report Correlation?",  buttonPressed);        dialog.addLabel("How should the contrast correlation be reported?");        dialog.addBlankLine();        String[] labels = new String[]{modes.getValue(REPORT_r), modes.getValue(REPORT_r2), modes.getValue(REPORT_p)};        RadioButtons radio = dialog.addRadioButtons(labels, 0);        dialog.addBlankLine();        dialog.completeAndShowDialog(true);        boolean ok = (dialog.query()==0);        if (ok){            reportMode = radio.getValue(); //change mode            modeName.setValue(modes.getValue(reportMode)); //so that menu item knows to become checked        }    }    public boolean requestPrimaryChoice(){        return true;    }    public CompatibilityTest getCompatibilityTest(){        return new ContinuousStateTest();    }    public void employeeQuit(MesquiteModule m){        if (m==contrastsTask)            iQuit();    }    /**     * add this method, which is used on file saving to remember what option was being used by this module.       * This is not a global preference, but is used during file reading when	 * Mesquite attempts to recover the analysis as done previously	 * 	 * @param file file that will receive the snapshot (though not used here)	 * */    public Snapshot getSnapshot(MesquiteFile file) {        Snapshot temp = new Snapshot();        temp.addLine("setReportMode " + StringUtil.tokenize(modes.getValue(reportMode)));        return temp;    }    /**     *  Add this method, which is the main command handling method.     */    public Object doCommand(String commandName, String arguments, CommandChecker checker) {        if (checker.compare(getClass(), "Sets the report mode", "[One of 'r','r-squared', or 'P value']", commandName, "setReportMode")) {            String name = parser.getFirstToken(arguments); //get argument passed of option chosen            int newMode = modes.indexOf(name); //see if the option is recognized by its name            if (newMode >=0 && newMode!=reportMode){                reportMode = newMode; //change mode                modeName.setValue(modes.getValue(reportMode)); //so that menu item knows to become checked                parametersChanged(); //this tells employer module that things changed, and recalculation should be requested            }        }        else            return  super.doCommand(commandName, arguments, checker);        return null;    }    /** Called to provoke any necessary initialization.  This helps prevent the module's intialization queries to the user from   	happening at inopportune times (e.g., while a long chart calculation is in mid-progress)*/    public void initialize(Tree tree, CharacterDistribution charStatesX, CharacterDistribution charStatesY){    }    /*.................................................................................................................*/    /*in future this will farm out the calculation to the modules that deal with appropriate character model*/    public  void calculateNumber(Tree tree, CharacterDistribution charStatesX, CharacterDistribution charStatesY, MesquiteNumber result, MesquiteString resultString) {          if (result==null)            return;        clearResultAndLastResult(result);        if (tree==null || charStatesX ==null || charStatesY ==null) {            if (resultString!=null)                resultString.setValue("Felsenstein Contrast Correlation can't be calculated because tree or characters not supplied");        }        else if (!(charStatesX instanceof ContinuousDistribution) || !(charStatesY instanceof ContinuousDistribution)) {            if (resultString!=null)                resultString.setValue("Felsenstein Contrast Correlation can't be calculated because characters supplied aren't continuous");        }        else {            final int numNodes = tree.getNumNodeSpaces();            xArray.resetSize(numNodes);            yArray.resetSize(numNodes);            MesquiteNumber resultX = new MesquiteNumber();            MesquiteNumber resultY = new MesquiteNumber();            contrastsTask.calculateNumbers(tree, charStatesX, xArray, null);            contrastsTask.calculateNumbers(tree, charStatesY, yArray, null);            for (int i=0; i<numNodes; i++) {                if (tree.nodeInTree(i) && tree.nodeIsInternal(i)) { //todo: have toggle for internal only                    xArray.placeValue(i, resultX);                    yArray.placeValue(i, resultY);                    if (resultX.isNegative()) {                        resultY.changeSign();                        resultX.abs();                        xArray.setValue(i, resultX);                        yArray.setValue(i, resultY);                    }                }            }            //because setting the df adjustment may not be possible in this context            //this will default to the most conservative df adjustment (e.g. adjust by            //# of polytomies).            NoPolyTree localTree;            if (tree instanceof NoPolyTree){                localTree = (NoPolyTree) tree;            }            else {                localTree = new NoPolyTree((MesquiteTree)tree);            }            PDAP2CTStatPak myStats = statPakTask.getStatPak();            int zlb = myStats.countZLBs(localTree);            if (zlb == localTree.getTerminalTaxa(localTree.getRoot()).length-2)                myStats.setDFReduction(zlb-1);            else                myStats.setDFReduction(zlb);            myStats.setTree(localTree);            myStats.setObserved1((ContinuousDistribution) charStatesX);            myStats.setObserved2((ContinuousDistribution) charStatesY);            myStats.doCalculations(xArray, yArray, null);            if (reportMode== REPORT_r){                result.setValue(myStats.getCorrelationCoefficient());                resultString.setValue("Felsenstein's contrasts correlation (r): " + result);            }            else if (reportMode== REPORT_r2){                final double d = myStats.getCorrelationCoefficient();                result.setValue(d*d);                resultString.setValue("Felsenstein's contrasts correlation (r2): " + result);            }            else if (reportMode== REPORT_p){                result.setValue(myStats.getPValue());                resultString.setValue("P-value of Felsenstein's correlation: " + result + "(df = " + myStats.getDegreesOfFreedom() +")");            }        }        saveLastResult(result);        saveLastResultString(resultString);    }    /*.................................................................................................................*/    public String getParameters(){        return "Felsenstein's Contrasts, reporting " + modeName.getValue();    }    /*.................................................................................................................*/    public String getName() {        return "Felsenstein's Contrasts Correlation";    }    /*.................................................................................................................*/    /** Returns the name of the module in very short form.  For use for column headings and other constrained places.  Unless overridden returns getName()*/    public String getVeryShortName(){        return "Correlation";    }    /*.................................................................................................................*/    public String getVersion() {        return "1.15";    }    /*.................................................................................................................*/    public boolean isPrerelease() {        return false;    }    /** marks the module as doing a substantive calculation - not decorative */    public boolean isSubstantive(){        return true;    }    /*.................................................................................................................*/    /** returns an explanation of what the module does.*/    public String getExplanation() {        return "Calculates the Pearson product-moment correlation between Felsenstein's contrasts of two characters on a tree, and reports it as an r, r2, or p value." ;    }}