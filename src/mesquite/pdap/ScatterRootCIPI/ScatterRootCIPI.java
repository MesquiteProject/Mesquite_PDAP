/* PDAP:PDTREE package for Mesquite  copyright 2001-2010 P. Midford & W. MaddisonPDAP:PDTREE is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.The web site for PDAP:PDTREE is http://mesquiteproject.org/pdap_mesquite/This source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.pdap.ScatterRootCIPI;/*~~  */import java.awt.*;import java.util.*;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.lib.tree.Tree;import mesquite.lib.ui.ChartExtra;import mesquite.lib.ui.Charter;import mesquite.lib.ui.MesquiteChart;import mesquite.pdap.lib.*;public class ScatterRootCIPI extends ScatterRegisterableAsst  {    public void getEmployeeNeeds(){  //This gets called on startup to harvest information; override this and inside, call registerEmployeeNeed        EmployeeNeed e = registerEmployeeNeed(RootRegressionCalculator.class, getName() + "  needs a method to calculate root regressions.",        "The method to calculate root regressions is selected initially");    }            private Vector<ChartExtra> extras;    RootRegressionCalculator rootStatTask;    PDAPTreeWinAsstC chartModule;        public boolean startJob(String arguments, Object condition, boolean hiredByName) {        extras = new Vector<ChartExtra>();        rootStatTask = (RootRegressionCalculator)hireNamedEmployee(RootRegressionCalculator.class, "#RootReconstructions");        if (rootStatTask == null)            return sorry(getName() + " couldn't start because no calculating module for root regression obtained.");        return true;    }    /*-----------------------------------------*/    /** */    public String getLegendText(){        return "";    }    public boolean suppliesWritableResults(){        return (rootStatTask.getStatPak() != null);    }    public Object getResultsHeading() {        return getName();    }    /**     *      */    public MesquiteNumber[] getWritableResults(){        return rootStatTask.getStatPak().getWritableResults();    }    /*-----------------------------------------*/    /**      * Avoid problems with multiple hiring      * @return false     */    public boolean canHireMoreThanOnce () {        return false;    }    /*-----------------------------------------*/    /** 	 * @param PDAPTreeWinAsstc     */    public void setChartModule(PDAPTreeWinAsstC module){        chartModule = module;        rootStatTask.setChartModule(module);    }    /*-----------------------------------------*/    /**     * creates a new chart extra; also attaches the chart to     * the rootStatTask which needs to draw	 * @param MesquiteChart 	 * @return ChartExtra     */    public ChartExtra createExtra(MesquiteChart chart){        rootStatTask.setChart(chart);        ChartExtra s = new SRDExtra(this, chart);        extras.addElement(s);        return s;    }	    /*-----------------------------------------*/    /**	 * @return false     */    public boolean getUserChooseable(){        return false;    }    /*-----------------------------------------*/    /**	@return String     */    public String getName(){        return "Scattergram Root Reconstruction Confidence Intervals";    }    /*.................................................................................................................*/    public String getAuthors() {        return "Peter E. Midford, Ted Garland Jr., and Wayne P. Maddison" ;    }    /*.................................................................................................................*/    /** 	@return String module version     */    public String getVersion() {        return "1.15";    }    /*.................................................................................................................*/    public boolean isPrerelease() {        return false;    }    /*-----------------------------------------*/    public void endJob(){        if (extras != null) {            for (int i=0; i<extras.size(); i++){                if (extras.get(i) != null){                    ChartExtra extra = (ChartExtra)extras.elementAt(i);                    extra.turnOff();                }                else                    MesquiteMessage.warnProgrammer("Found a null entry in the list of chartExtras of the ScatterRootCIPI while ending");            }        }        super.endJob();    }} //end class scatterRootCIPI/*-----------------------------------------*/class SRDExtra extends ChartExtra {    CharacterDistribution cd1;    CharacterDistribution cd2;    Tree tree;    int dfReduce;    public SRDExtra(MesquiteModule ownerModule, MesquiteChart chart){        super(ownerModule, chart);    }    /*-----------------------------------------*/    private NumberArray calculationsResult = new NumberArray(1);    private MesquiteString calculationsResultString = new MesquiteString();    /**	@param CommandRecord	@return Boolean true if the chart needs to redraw (munch)	collects the characters and the tree and passes them to the rootStatTask to calculate	statistics.     */    public boolean doCalculations(){         if (((ScatterRootCIPI)ownerModule).chartModule == null)            return false;        cd1 = ((ScatterRootCIPI)ownerModule).chartModule.getObserved1();        cd2 = ((ScatterRootCIPI)ownerModule).chartModule.getObserved2();        tree = ((ScatterRootCIPI)ownerModule).chartModule.getTree();        dfReduce = ((ScatterRootCIPI)ownerModule).chartModule.getDFReduction();        // Here the root diagnostics module should be consulted to calculate what is needed        //NumberArray result = new NumberArray(1);        //MesquiteString resultString = new MesquiteString("");        calculationsResult.setToUnassigned(0);        calculationsResultString.setValue("");        PDAP2CTStatPak rootStats = ((ScatterRootCIPI)ownerModule).rootStatTask.getStatPak();        rootStats.setWidth1(((ScatterRootCIPI)ownerModule).chartModule.getWidth1());        rootStats.setIgnoreRootTritomies(((ScatterRootCIPI)ownerModule).chartModule.getIgnoreRootTritomies());        rootStats.countZLBs(tree);        ((ScatterRootCIPI)ownerModule).rootStatTask.calculateNumbers(tree,cd1,cd2,calculationsResult,calculationsResultString);        if ("Needs remunching".equals(calculationsResultString.getValue())){            calculationsResultString.setValue("Reconstructed Root Values");            return true;        }        else            return false;    }    /*-----------------------------------------*/    /**	@param Graphics awt representation of the display pane/page	tells the rootStatTask's statPak to draw the appropriate 'target' display     */    public void drawOnChart(Graphics g){        final PDAP2CTStatPak rootStats = ((ScatterRootCIPI)ownerModule).rootStatTask.getStatPak();        final Charter c = chart.getCharter();        if (rootStats == null)            return;        if (!MesquiteDouble.isCombinable(rootStats.getLeastSquaresSlope()))            return;        if (c == null)            return;            final int BRACKETWIDTH = 5;   //half width of the brackets at the end of error bars        final double mean0 = rootStats.getMean(0);        final double mean1 = rootStats.getMean(1);        final double ci0 = rootStats.getCI(0);        final double ci1 = rootStats.getCI(1);        // cache the root's position on the graph        final int rootX = c.xToPixel(mean0,chart);        final int rootY = c.yToPixel(mean1,chart);        // start by drawing error bars for the CI  in both dimensions        final int xLowerBound = c.xToPixel(mean0-ci0,chart);        final int xUpperBound = c.xToPixel(mean0+ci0,chart);        final int yLowerBound = c.yToPixel(mean1-ci1,chart);        final int yUpperBound = c.yToPixel(mean1+ci1,chart);        g.setColor(Color.green);        g.drawLine(xLowerBound,rootY,xUpperBound,rootY);        g.drawLine(xLowerBound,rootY-BRACKETWIDTH,xLowerBound,rootY+BRACKETWIDTH);        g.drawLine(xUpperBound,rootY-BRACKETWIDTH,xUpperBound,rootY+BRACKETWIDTH);        g.drawLine(rootX,yLowerBound,rootX,yUpperBound);        g.drawLine(rootX-BRACKETWIDTH,yLowerBound,rootX+BRACKETWIDTH,yLowerBound);        g.drawLine(rootX-BRACKETWIDTH,yUpperBound,rootX+BRACKETWIDTH,yUpperBound);        // finally put up a small circle or rectangle in the root's location itself        g.setColor(Color.red);        // not yet sure how to do this, so I'll just draw a small rectangle        g.drawLine(rootX-1,rootY-1,rootX+1,rootY-1);        g.drawLine(rootX-1,rootY,rootX+1,rootY);        g.drawLine(rootX-1,rootY+1,rootX+1,rootY+1);    }    /*-----------------------------------------*/    /**	@param Graphics awt representation of the output page	pass through entry for printing the chart*/    public void printOnChart(Graphics g){        drawOnChart(g);    }    /*-----------------------------------------*/    /** This returns the string to dump on the text pane of the PDAP window.  It just gets the string returned by        the rootStatPak. */    public String writeOnChart(){        PDAP2CTStatPak rootStats = ((ScatterRootCIPI)ownerModule).rootStatTask.getStatPak();        if (rootStats != null)            return rootStats.flst();        else            return "Error: no root statistics were calculated.";    }    /*-----------------------------------------*/    /** Entrypoint to inform ChartExtra that cursor has just entered a plot on the scatterplot.  Future use?*/    public void cursorEnterPoint(int point, int exactPoint, Graphics g){        //Debugg.println("enter point " + point);    }    /*-----------------------------------------*/    /** Entrypoint to inform ChartExtra that cursor has just exited a plot on the scatterplot.  Future use?*/    public void cursorExitPoint(int point, int exactPoint, Graphics g){        //Debugg.println("exit point " + point);    }    /**to inform ChartExtra that cursor has just touched point*/    public void cursorTouchPoint(int point, int exactPoint, Graphics g){        //Debugg.println("touch point " + point);    }}