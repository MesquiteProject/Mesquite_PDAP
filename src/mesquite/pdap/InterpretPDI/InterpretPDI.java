/* PDAP:PDTREE package for Mesquite  copyright 2001-2009 P. Midford & W. MaddisonPDAP:PDTREE is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.The web site for PDAP:PDTREE is http://mesquiteproject.org/pdap_mesquite/This source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.pdap.InterpretPDI;/*~~  */import java.util.HashSet;import java.util.Set;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.lib.duties.*;import mesquite.pdap.lib.NoPolyTree;import mesquite.cont.lib.*;/* ============  a file interpreter for PDI files used by PDAP (Garland et al. 1993) ============*/public class InterpretPDI extends FileInterpreterI {        // These are strictly historical    final static private String PDAP_UNASSIGNED_PADDED =  "  -9.9999999999E-99";    final static private String PDAP_UNASSIGNED = "-9.9999999999E-99";        //possibilities: 0-8    final static private String indexString = "#-+*:.=!";        final static private String MOTHER_OF_ROOT_NAME = "$$";        // Strings for messages    final static private String POLYTOMY_EXPORT_WARNING = "Arbitrary resolution of polytomies into zero-length branches has occurred.\n" +    		"Statistics may differ from program to program";                     final private StringBuffer genBuffer = new StringBuffer(2);        /*.................................................................................................................*/    public boolean startJob(String arguments, Object condition, boolean hiredByName) {        return true;  //make this depend on taxa reader being found?)    }    /*.................................................................................................................*/    public boolean canExport() {        return (getProject().getNumberCharMatrices(ContinuousState.class) > 0);         //return false;    }    /*.................................................................................................................*/    public boolean canImport() {        return true;    }    //TODO check this code for ASCII character encoding dependency    private String processName(String name){        if (name == null)            return "";        if (MOTHER_OF_ROOT_NAME.equals(name))            return name;        int result = 0;        if (name.length()>=1){            char c = name.charAt(0);            if (c>='0' && c<='9')                result += 0;            else if (c>='a' && c<='z')                result += 1;            else if (c>='A' && c<='Z')                result += 2;        }        if (name.length()>=2){            char c = name.charAt(1);            if (c>='0' && c<='9')                result += 0;            else if (c>='a' && c<='z')                result += 3;            else if (c>='A' && c<='Z')                result += 6;        }        if (result<8) //result is a case encoding if result is 8, name is two caps, no code appended            return name + indexString.charAt(result);        else            return name;    }    // Generate a two character internal node name.  Unlike PDNEXUS, we don't maintain a counter    // since the node already has a unique index in the tree.  Otherwise it has the same (912)    // node limitation.    //TODO check for ASCII character coding dependency    private String genName(int nodeIndex) {        final int n1 = nodeIndex / 36;        final int n2 = nodeIndex % 36;        char ch1;         char ch2;        genBuffer.setLength(0);        if (n1 <= 25)            ch1= (char)(65+n1);        else            ch1= (char)(71+n1);        if (n2 <= 9)            ch2 = (char)(48+n2);        else            ch2 = (char)(55+n2);        genBuffer.append(ch1);        genBuffer.append(ch2);        return genBuffer.toString();    }    // This converts zlbs to polytomies    private void cleanupZLBs(MesquiteTree tree, int nd){        if (tree.nodeIsInternal(nd)){                        for (int daughter = tree.firstDaughterOfNode(nd); tree.nodeExists(daughter); daughter = tree.nextSisterOfNode(daughter))                cleanupZLBs(tree, daughter);            if (tree.getRoot() != nd){                if (tree.getBranchLength(nd) == 0){                    tree.collapseBranch(nd, false);                }            }        }    }    /*.................................................................................................................*/    public void readFile(MesquiteProject mf, MesquiteFile file, String arguments) {        if (mf == null){            alert("InterpretPDI got a null project argument", "InterpretPDI null project", "InterpretPDI null project" );            return;        }        if (file == null){            alert("InterpretPDI got a null file argument", "InterpretPDI file project", "InterpretPDI null file");            return;        }                incrementMenuResetSuppression();        ProgressIndicator progIndicator = new ProgressIndicator(mf,"Importing File "+ file.getName(),file.existingLength());        progIndicator.start();        file.linkProgressIndicator(progIndicator);        if (file.openReading()) {            boolean abort = false;            TaxaManager taxaTask = (TaxaManager)findElementManager(Taxa.class);            CharactersManager charTask = (CharactersManager)findElementManager(CharacterData.class);            // The number of taxa is on the first line of the file            String line = file.readLine();            parser.setString(line);            String token = parser.getNextToken();            final int numTaxa = MesquiteInteger.fromString(token);            if (!MesquiteInteger.isCombinable(numTaxa) || numTaxa == 0)                abort = true;            TreeVector trees = null;            MesquiteTree tree =null;            CharacterData data = null;            final Taxa taxa = taxaTask.makeNewTaxa(getProject().getTaxas().getUniqueName("Taxa from PDIfile"), numTaxa, false);            if (taxa !=null){                // This doesn't work...                //for (int i = 0; i<numTaxa; i++)                //	taxa.setTaxonName(i, ""); //to catch errors                taxa.addToFile(file, getProject(), taxaTask);                data = charTask.newCharacterData(taxa, 0, ContinuousData.DATATYPENAME);                data.addToFile(file, getProject(), null);                line = file.readLine(); //eat up blank line            }            else                abort = true;            // read the tree structure.            /* note change in taxon and node names: because NEXUS is not case sensitive, and PDI is, the interpreter has to adjust for nodes and taxa and                names that differ only in case.  This interpreter used to try to adjust subsequent names differing only in case, but that was fraught with problems.  Hence an annoying               but foolproof substitute was used: each name gets converted by processName to add an extra character which depends on whether the two characters of the name are               upper or lower case or numerical*/            if (!abort) {                trees = new TreeVector(taxa);                tree = new MesquiteTree(taxa);                MesquiteInteger pos = new MesquiteInteger(0);                for (int i = 0;i < 2*numTaxa-1 && !abort; i++) {                    line = file.readLine();                    //get name of current node                    String currentNodeName = processName(parser.getFirstToken(line));                    //get name of ancestral node                    String ancestralNodeName = processName(parser.getNextToken());                    //get branch length                    pos.setValue(parser.getPosition());                    double length = MesquiteDouble.fromString(line, pos);                    parser.setPosition(pos.getValue());                    if (MOTHER_OF_ROOT_NAME.equals(ancestralNodeName)) {                        int root = tree.getRoot();                        tree.setNodeLabel(currentNodeName, root);                        tree.setBranchLength(root, length, false);                    }                    else {                        int ancestralNode = tree.nodeOfLabel(ancestralNodeName, true);                        if (!tree.nodeExists(ancestralNode)){                            alert(ancestralNodeName+" ancestor of "+currentNodeName+" does not exist",                                    "PDI Missing Ancestor",                             "PDI Missing Ancestor");                            abort = true;                        }                        else {                            int sprouted = tree.sproutDaughter(ancestralNode, false);                            tree.setNodeLabel(currentNodeName, sprouted);                            tree.setBranchLength(sprouted, length, false);                        }                    }                }                tree.setName("PDI tree");                trees.addElement(tree, false);                trees.addToFile(file,file.getProject(),findElementManager(TreeVector.class));            }            line = file.readLine(); //eat up blank line            int taxaCounter = 0;            // now we're reading a two character name, followed by two doubles            line = file.readLine();            while (!StringUtil.blank(line)&& !abort) {                parser.setString(line);                token = processName(parser.getNextToken());                Taxon t = taxa.getTaxon(taxaCounter);                if (t!=null) {                    t.setName(token);                    progIndicator.setText("Reading taxon: "+token);                    int ic = 0;                    while (parser.getPosition()<line.length()) {                        if (data.getNumChars() <= ic) {                            data.addCharacters(data.getNumChars()-1, 1, false);   // add a character if needed                        }                        data.setState(ic,taxaCounter, parser, false, null);                        StringBuffer valueString = new StringBuffer(20);                        data.statesIntoStringBuffer(ic,taxaCounter,valueString,false);                        if (valueString.toString().equalsIgnoreCase(PDAP_UNASSIGNED)){                            ContinuousState bar = new ContinuousState(MesquiteDouble.unassigned);                            bar.setNumItems(1);                            bar.setToUnassigned();                            data.setState(ic, taxaCounter,bar);                        }                        ic++;                    }                }                taxaCounter++;                line = file.readLine();                if (file.getFileAborted()) {                    abort = true;                }            }            if (!abort && tree!=null){                for (int i = 0; i< tree.getNumNodeSpaces();i++) {                    if (tree.nodeExists(i)){                        if (tree.nodeHasLabel(i) && tree.nodeIsTerminal(i)){ //terminal node with label; find taxon                            String label = tree.getNodeLabel(i);                            int whichTaxon = taxa.whichTaxonNumber(label, true);                            if (whichTaxon>=0) //found taxon label                                tree.setTaxonNumber(i, whichTaxon, false);                        }                    }                }                tree.setAsDefined(true);            }            if (!taxaOK(taxa)) {                alert("The PDI file could not be read successfully.  It may have been misformatted.");                abort = true;            }            // Need to convert PDAP ZLB's into Mesquite polytomies            // Discussion with TG on 7 August 2009 decided to remove this because it causes inconsistent            // results in diagnostic screens (not 9, 9A) when PDAPDiagnosticScreen converts these back            // into ZLBs.  Maybe we should add a switch (default off) or a separate command if people            // want this functionality.            // Further discussion (2 October 2009) we will leave this in and add warning to the results on screens            // 1-6.  Note that if you want to actually check the calculations for a polytomy, you can read a PDI file,            // do the calcuations in Mesquite, then save a new copy of the PDI file, which will use the same resolution of            // polytomies into ZLB's as Mesquite uses internally.  This new PDI should produce identical results in DOS PDTREE.            cleanupZLBs(tree,tree.getRoot()); // ->polytomies            finishImport(progIndicator, file, abort);            MesquiteModule treeWindowCoord = getFileCoordinator().findEmployeeWithName("#BasicTreeWindowCoord");            if (treeWindowCoord!=null){                CommandRecord rec = MesquiteThread.getCurrentCommandRecord();                MesquiteThread.setCurrentCommandRecord(CommandRecord.scriptingRecord);                String commands = "makeTreeWindow " + getProject().getTaxaReference(taxa) + "  #BasicTreeWindowMaker; tell It; ";                commands += "setTreeSource  #StoredTrees; tell It; setTaxa " + getProject().getTaxaReference(taxa) + " ;  setTreeBlock 1; endTell; ";                commands += "getTreeDrawCoordinator #BasicTreeDrawCoordinator; tell It; suppress; setTreeDrawer #SquareTree; ";                commands += "tell It; setEdgeWidth 4; getEmployee #NodeLocsStandard; tell It; branchLengthsToggle on; ";                commands += " endTell; endTell; desuppress; endTell;";                commands += "getTreeWindow; tell It;  setSize 500 400; setLocation 150 70;   showWindow; newWindowAssistant #PDAPDiagnosticChart; tell It; setCharacterSource  #StoredCharacters; ";                commands += "getWindow; tell It; setSize 600 400; setLocation 300 150; endTell; showWindow; endTell; endTell;";                commands += "endTell; ";                MesquiteInteger pos = new MesquiteInteger(0);                Puppeteer p = new Puppeteer(this);                p.execute(treeWindowCoord, commands, pos, null, false);                MesquiteThread.setCurrentCommandRecord(rec);                MesquiteThread.setCurrentCommandRecord(rec);            }        }        //TODO why is this here - does something require activity in the log at this point?        logln(""); // ,0,0);        decrementMenuResetSuppression();    }  // InterpretPDI.readFile()    private boolean taxaOK(Taxa taxa){        if (taxa == null || taxa.getNumTaxa() == 0)            return false;        for (int i=0; i<taxa.getNumTaxa(); i++)            if (StringUtil.blank(taxa.getTaxonName(i)))                return false;        return true;    }    /* ============================  exporting ============================*/    boolean includeGaps = false;    /*.................................................................................................................*/    public boolean getExportOptions(boolean dataSelected, boolean taxaSelected){        MesquiteInteger buttonPressed = new MesquiteInteger(1);        ExporterDialog exportDialog = new ExporterDialog(this,containerOfModule(), "Export PDI Options", buttonPressed);        exportDialog.completeAndShowDialog(dataSelected, taxaSelected);        boolean ok = (exportDialog.query(dataSelected,taxaSelected)==0);        exportDialog.dispose();        return ok;    }    // PDI is two characters, case sensitive, so we'll just strip the extra characters (if any) added by processName.    //Of course this assumes the case was not mangled somewhere, and that the first two characters are unique (if    //this wasn't originally a PDI file.    private String unProcessName(String name) {        if (name.length() <= 2)            return name;        else            return name.substring(0,2);    }    private String[] nameArray = null;    private Set<String> nameUsed = new HashSet<String>();    /*..............................................................*/    /**     * This protects the two character names of non-conflicting and first found conficting     * tips.     */    private void namePass1(Tree tree, int node){        if (tree.nodeIsInternal(node)){            for (int daughter = tree.firstDaughterOfNode(node); tree.nodeExists(daughter); daughter = tree.nextSisterOfNode(daughter))                namePass1(tree,daughter);          }        else {            final String rawName = tree.getNodeLabel(node);            if (rawName != null){                final String shortName = unProcessName(rawName);                if (!nameUsed.contains(shortName)){                    nameUsed.add(shortName);                    nameArray[node] = shortName;                }            }        }    }    /**     * This fills in names for conflicting tips and internal nodes.     * @param tree the Tree to save     * @param node int specifying the node in the tree that needs a name     */    private void namePass2(Tree tree, int node){        if (tree.nodeIsInternal(node)){            for (int daughter = tree.firstDaughterOfNode(node); tree.nodeExists(daughter); daughter = tree.nextSisterOfNode(daughter))                namePass2(tree,daughter);          }        if (nameArray[node] == null){ // name not already assigned            int idx = node;            String newName = genName(idx);            while(nameUsed.contains(newName))                newName = genName(idx++);            nameUsed.add(newName);            nameArray[node]=newName;        }       }    /**     * This walks through the tree and assigns each node, internal and external     * a two-character identifier for the duration of this file.  Doing this once     * avoids collisions     */    private void setNames(Tree tree, int root){        if (nameUsed == null)            nameUsed = new HashSet<String>();        else            nameUsed.clear();        if (nameArray == null || nameArray.length != tree.getNumNodeSpaces())            nameArray = new String[tree.getNumNodeSpaces()];        for (int i= 0;i<nameArray.length;i++)            nameArray[i]= null;        namePass1(tree,root);        namePass2(tree,root);                }    /*...............................................................*/    // This writes the node, its ancestor and the length of the branch.    private void exportNode(Tree tree, StringBuffer outputBuffer, int node) {        final String myName = nameArray[node];        String mothersName;        double length;        if (node != tree.getRoot()) {            mothersName = nameArray[tree.motherOfNode(node)];            length = tree.getBranchLength(node,1.0);        }        else {            mothersName = MOTHER_OF_ROOT_NAME;  // PDAP tag for 'mother of root'            length = 0.0;  // PDAP convention, BL of root == 0        }        outputBuffer.append(myName + " " + mothersName + "  ");        outputBuffer.append(MesquiteDouble.toFixedWidthString(length,15));        outputBuffer.append(getLineEnding());        for (int daughter = tree.firstDaughterOfNode(node); tree.nodeExists(daughter); daughter = tree.nextSisterOfNode(daughter))            exportNode(tree, outputBuffer, daughter);    }    private void exportTaxaValues(Tree tree, StringBuffer outputBuffer, int node, ContinuousData data) {        if (tree.nodeIsInternal(node)) {            for (int daughter = tree.firstDaughterOfNode(node); tree.nodeExists(daughter); daughter = tree.nextSisterOfNode(daughter))                exportTaxaValues(tree, outputBuffer, daughter, data);        }        else {            final Taxa taxa = data.getTaxa();            final int numChars = data.getNumChars();            for (int it = 0; it < taxa.getNumTaxa(); it ++) {                if (taxa.getTaxonName(it).equals(tree.getNodeLabel(node))) {  // what we want; matching Mesquite names                    String myName = nameArray[node];  //but we want to save the generated PDAP name                    outputBuffer.append(myName);                    int charsWritten = 0;                    for (int ic = 0; ic<numChars; ic++) {                        if (!writeOnlySelectedData || (data.getSelected(ic))){                            final double state = data.getState(ic,it,0);                            if (!MesquiteDouble.isCombinable(state))                                outputBuffer.append(PDAP_UNASSIGNED_PADDED);                            else{                                if (state < 0)                                    outputBuffer.append("  "); // adjust spacing for '-' sign                                else                                    outputBuffer.append("   ");  // TAG doesn't like tabs in data files.                                outputBuffer.append(MesquiteDouble.toFixedWidthString(state,15));                            }                            charsWritten++;                        }                    }                    while (charsWritten < 2) {                        outputBuffer.append(PDAP_UNASSIGNED_PADDED);                        charsWritten++;                    }                    outputBuffer.append(getLineEnding());                    charsWritten = 0;                }            }        }    }    /*.................................................................................................................*/    /**     * @param file a MesquiteFile     * @param arguments     *       */    // Since PDI files necessarily describe trees, there should never be a reason for only    // writing selected taxa.  Selected characters are another issue entirely.  For now, we'll    // default to the original behavior (all characters unless some are selected).  Although PDTREE    // will only recognize the first two, it won't choke on the rest of the line.  Same for any PDAP    // module that uses T_IO1, as it should.  PEM 23 Jul 2001    // Code for formated output (so columns are fixed width) added 13 Sept 2002 PEM    // If only one character is available, write a second column of invalid values to keep PDTREE    // happy (maybe duplicate the first column?) 10 Aug 2005 PEM    public boolean exportFile(MesquiteFile file, String arguments) {         final ContinuousData data = (ContinuousData)getProject().chooseData(containerOfModule(), null, null, ContinuousState.class, "Select data for PDI export");        final Taxa taxa = data.getTaxa();        if (!getExportOptions(data.anySelected(), taxa.anySelected()))            return false;        final int numTaxa = taxa.getNumTaxa();        OneTreeSource source = (OneTreeSource)hireEmployee(OneTreeSource.class,"Select a source of trees");        Tree tree = source.getTree(taxa);        if (tree == null)            return false;        // Check that the tree is a NoPolyTree        if (!(tree instanceof NoPolyTree))            tree = new NoPolyTree((MesquiteTree)tree);        if (((NoPolyTree)tree).hasZLBs(false)){            alert(POLYTOMY_EXPORT_WARNING);        }                    final int root = tree.getRoot();        setNames(tree,root);        final StringBuffer outputBuffer = new StringBuffer(80*(2*numTaxa+3));        outputBuffer.append(tree.numberOfTerminalsInClade(root) + getLineEnding() + getLineEnding());        setNames(tree, root);        exportNode(tree,outputBuffer,root);        outputBuffer.append(getLineEnding());        exportTaxaValues(tree,outputBuffer,root,data);        String name = getProject().getHomeFileName();        if (name==null)            name = "untitled.pdi";        else             name = stripNex(name) + ".pdi";        saveExportedFile(outputBuffer.toString(), arguments, name);        return true;    }    /*.................................................................................................................*/    public String getName() {        return "Import/Export PDI (PDAP see Garland et. al. 1993)";    }    /*.................................................................................................................*/    public String getAuthors() {        return "Peter E. Midford, Ted Garland Jr., David Maddison and Wayne P. Maddison";     }    /*.................................................................................................................*/    public String getVersion() {        return "1.15";    }    /*.................................................................................................................*/    public boolean isPrerelease() {        return false;    }    /*.................................................................................................................*/    /** returns an explanation of what the module does.*/    public String getExplanation() {        return "Imports/Exports PDI format files used by Garland's PDAP package." ;    }    /*.................................................................................................................*/    /** returns current parameters, for logging etc..*/    public String getParameters() {        return "" ;    }}